#Multithreading

Все стандартные атомарные типы определены в заголовке [[atomic std header]].

В большинстве атомарных типах есть  метод  is_lock_free(), которая сообщает выполняются ли операции над данным типом с помощью действительно атомарных команд (true) или с применением некоторой внутренней для компилятора и библиотеки блокировки

Единственный тип, в котором функция-член is_lock_free() отсутствует, – это [[std_atomic_flag]]. В действительности это по-настоящему простой булевский флаг, а операции над этим типом обязаны быть свободными от блокировок

Доступ ко всем остальным атомарным типам производится с помощью специализаций шаблона класса [[std_atomic]]; их функциональность несколько богаче, но они необязательно свободны от блокировок.

Любые операции над атомарным типом должны быть атомарными, а для присваивания и конструирования копированием нужны два объекта.
Никакая операция над двумя разными объектами не может быть атомарной. В случае копирования и присваивания необходимо сначала прочитать значение первого объекта, а потом записать его во второй.

все поддерживаемые ими операторы присваивания возвращают значения (соответствующего неатомарного типа), а не ссылки
