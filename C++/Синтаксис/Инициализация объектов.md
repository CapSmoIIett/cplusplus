
[Эффективный и современныи С++: 42 рекомендации по использованию С++ 11 и С++ 14 - Скотт Мейерс](https://github.com/CapSmoIIett/cplusplus/blob/main/Books/%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%B8_%D1%81%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%A1_%D0%A1%D0%BA%D0%BE%D1%82%D1%82_%D0%9C%D0%B5%D0%B9%D0%B5%D1%80%D1%81.pdf) - Глава 3.1


Как правило, инициализирующие значения указываются с помощью круглых скобок, знака равенства или фигурных скобок:

```c++
    int х (0);     // Инициализатор в круглых скобках
    int у = 0;     // Инициализатор после "="
    int z { 0 };   // Инициализатор в фигурных скобках 
    int z = { 0 }; // Инициализатор использует "=" и фигурные скобки (обычно эквивалентен обычным {})
```
[Подробнее о фигурных скобках](initializer_list)

Разница между способами инициализации проявляется в случае пользовательских типов данных
```c++
    Widget wl ;     // Вызов конструктора по умолчанию
    Widget w2 = wl; // Не присваивание, а копирующий конструктор
    wl = w2 ;   // Присваивание ; вызов оператора operator= () 
```

Унифицированная инициализация(uniform initialization) - это идея. Фигурная инициализация - это синтаксическая конструкция.

С помощью фигурных скобок легко указать начальное содержимое контейнера:
```c++
std::vector<int> v{ 1, 3, 5 }; // v иэначально содержит 1, 3, 5
```

Фигурные скобки могут также использоваться для указания значений инициализации
по умолчанию для нестатических членов-данных
```c++
class Widget
{
private:
    int х{ 0 }; // ОК, эначение х по умолчанию равно 0
    int у = 0;  // Тоже ОК
    int z(0) ;  // Ошибка !
}
```

С другой стороны, некопируемые объекты (например, std::atomic - см. раздел 7.6)
могут быть инициализированы с помощью фигурных или круглых скобок, но не с помощью знака равенства: 
```c++
std::atomic<int> ai1 { 0 }; // ОК
std::atomic<int> ai2 (0); // ОК
std::atomic<int> ai3 = 0; // Ошибка! 
```

Фигурная инициализация запрещает неявные сужающие преобразования.
Инициализация с использованием круглых скобок и знака равенства не выполняет проверку сужающего преобразования.
Если значение выражения в фигурном инициализаторе не может быть гарантированно 
выражено типом инициализируемого объекта, код не компилируется: 
```c++
double х, у, z;
int suml { х + у + z }; // Ошибка! Сумма double может
                        // не выражаться с помощью int

int sum2 (x + y + z); // ОК ( значение выражения усекается до int )
int sumЗ = x + y + z; //
```

Все, что в ходе синтаксического анализа может рассматриваться как
объявление, должно рассматриваться как таковое

Вызов конструктора без аргументов фактически является объявлением функции (фиксим это {}):
```c++
Widget w1(); // Есть вопросы
Widget w2{}; // Вопросов нет
```

Минусы использования везде {} -  [initializer_list](#initializer_list)

#### Тут начинаются приколы:
#### Прикол №1:

```c++
class Widget
{
    Widget (int i, int b);      // 1
    Widget (int i, bool b);     // 2
    Widget (std::initializer_list<int> il);  // 3
}

    Widget{1, true};    // вызов 3
    Widget(1, true);    // вызов 2
	Widget{1, 1};       // вызов 3
    Widget(1, 1);       // вызов 1
```

Объявление объекта фигурными скобками, всегда будет предпочитать конструктор 
с initializer_list

#### Прикол №2
```c++
void func(vector<string> v) { }

void func(vector<wstring> v) { }

int main() {
  func({"apple", "banana"});
}
```
резульатом будет call of overloaded func(brace-enclosed initializer list) is ambiguous
Это получается т.к. вызов подходит для первой перегрузки (initializer_list to vector),
а со второй перегрузкой, приведение к вектору строк не походит, но у vector есть конструктро принимающий два итератора который подхоит.
```c++
template<typename InputIterator>
vector(InputIterator first, InputIterator last, 
const allocator_type& a = allocator_type());
```

#### Прикол №3

```c++
class Widget
{
    encode (std::string);      // 1
    encode (std::vector<string>);     // 2
}

    encode({" "});  // ambiguous call to overloaded function
```