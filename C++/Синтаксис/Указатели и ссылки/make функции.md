
**std::make_unique и std::make_shared против new**

Три make-функции. 
Принимающие произвольное количество аргументов и производящие 
прямую передачу конструктору данного объекта и возвращающие умный указатель:
- std::make_unique
- std::make_shared
- std::allocate_shared (аналогичен std::make_shared, за исключением того, 
что первым аргументом является объект распределителя, использующийся для выделения динамической памяти.)

```c++
auto upw1 (std::make_unique<Widget>());     // С make-функицей
std::unique_ptr<Widget> upw2(new Widget);   // Без

auto spw1 (std::make_shared<Widget>());     // С make-функицей
std::shared_ptr<Widget> spw2(new Widget);   // Без
```

Плюсы make-функций:
- Можно работать с auto;
- Безопасность исключений

```c++
void processWidget (std::shared_ptr<Widget> spw, int priority);
...
{
    processWidget(std::shared_ptr<Widget>(new Widget), compPrior());    
    // Тут возможна утечка Widget
    // Это связано с тем как компилятор транслирует исходный код в объектный 
    // Во время выполнения аргументы функциии должны быть вычеслены до вызова функции, 
    // До выполнения processWidget произойдет следующее
    //  - new Widget создаст в динамической памяти объект Widget
    //  - Будет вызван конструктор std::shared_ptr<Widget>
    //  - Будет вызван compPrior
    // Последовательность выполнения этих действий не определена 
    // и если compPrior будет вызван после new и до создание указателя,
    // указатель созданный new будет утерян и будет вызвано исключение  
}
```

- Если не исопльзовать make-функции, то создание std::share_ptr использует два выделения памяти 
(для объекта и для управляющего блока)
(std::make_shared выделяет один блок памяти для одного и для другого)

Ситуации при которых не стоит использовать make-функции:
- Если нужно задать пользовательский удалитель.
- трудности с [[std_initializer_list]] (но по умолчанию используются круглые скобки)
- Если для класа переопределены *operator new* и *operator delete* (глобальные методы выделения памяти и удаления не подходят)
- Выделеный блок памяти с помощью make-функции (управляющий блок рядом с данными) существует пока обычный и weak счетчики не равны 0. Память для данных не будет освобождена пока существует хотя бы один std::shared_ptr или std::weak_ptr.

- По сравнению с непосредственным использованием new, mаkе-функции устраняют дублирование кода, повышают безопасность кода по отношению к исключениям и в случае функций std::make_shared и std::allocate_shared генерируют меньший по размеру и более быстрый код.
- Ситуации, когда применение mаkе-функций неприемлемо, включают необходимость указания  пользовательских удалителей и необходимость передачи инициализаторов в фигурных скобках.
- Для указателей std::shared_ptr дополнительными ситуациями, в которых применение mаkе-функций  может быть неблагоразумным, являются классы с пользовательским управлением памятью и системы, в которых проблемы с объемом памяти накладываются на использование очень больших объектов и наличие указателей std::weak_ptr, время жизни которых существенно превышает время жизни указателей std::shared_ptr. 

