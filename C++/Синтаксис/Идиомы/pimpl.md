
*pointer to implementation - указатель на реализацию*

Идиома **pimpl** - полезна в тех случаях, когда нам нужно что-то скрыть. 
Она обеспечивает еще более глубокий вид инкапсуляции, которая маскирует не просто реализацию, а также все ее зависимости.
Нужна для:
1. Для того, что бы была возможность изменять реализацию скрываемого класса без перекомпиляции остального кода, так как закрытые члены хоть и недоступны извне никому, кроме функций-членов и друзей, но видимы всем, кто имеет доступ к определению класса. Изменение определения класса приводит к необходимости перекомпиляции всех пользователей класса
2. Для сокрытия имен из области видимости. Закрытые члены хоть и не могут быть вызваны кодом вне класса, тем не менее они участвуют в поиске имен и разрешении перегрузок
3. Для ускорения времени сборки, так как компилятору не нужно обрабатывать лишние определения закрытых типов

Как мы этого добиваемся?
Переносим #include <название библтотеки> из .h в .cpp.
В .h дописываем необзодимый include

До:
```c++
// .h
#include "HideClass.h"

class A 
{
public:
    void fun();

private:
    HideClass b;
}


// .cpp
void A::fun()
{ /*Do something*/}
```

После:
```c++
// .h
class HideClass;

class A
{
public:
    A();
    ~A();
    void fun();

private:
    HideClass* b;
}


// .cpp
#include "HideClass.h"

A::A():
    b (new HideClass)
{ /*Do something*/}

A::~A()
{ delete b; }

void A::fun()
{ /*Do something*/}
```

В С++, в случае изменений в классе (даже в закрытых функциях членах) все пользователи данного класса должны быть перекомпилированы. 
Для избежания подобных зависимостей используется указатель на функции члены, реализацию которых необходимо скрыть.
Два основных недостатка заключаются в следующем:
1. Каждое создание объекта требует динамического выделения памяти для объекта, на который ссылается указатель
2. Использование нескольких уровней косвенности (как минимум — один) для доступа к членам скрытого объекта

Что же можно попробовать скрыть?

1. Только скрытые данные-члены
2. Все скрытые данные-члены и функции-члены. К сожалению, скрыть виртуальную функцию невозможно, так как она должна быть видима для производных классов. Также в закрытом классе может понадобиться ссылка на открытый класс для использования его функций
3. Закрытые и защищенные члены. К сожалению, защищенные члены скрыть нельзя, так как они должны быть доступны производным классам
4. Весь класс. Преимущество заключается в том, что закрытому классу не нужен указатель на открытый класс. С другой стороны, мы лишаемся возможностей наследования

(Сам до конца не понимаю указанное выше)

И еще: 
```c++
// .h
class HideClass;

class A
{
public:
    A();
    ~A();
    void fun();

private:
    int hideClassSize = 42;
    char hideClassObj[hideClassSize];
}


// .cpp
#include "HideClass.h"

A::A()
{
    assert(hideClassSize >= sizeof(HideClass));
    new(&hideClassObj[0]) HideClass;
}

A::~A()
{
    (reinterpret_cast<HideClass *> (&hideClassObj[0]))->~HideClass();
}

void A::fun()
{ /*Do something*/}

```

Кодом выше получилось избавиться отдинамического выделения памяти.

Нам удалось избавиться от объявления класса UnixSocketImpl в заголовочном файле GeneralSocket, и избавиться от динамического выделения памяти. Взамен мы получили ряд существенных недостатков:

1. С++ — язык со строгой типизацией, и данное ухищрение – попытка обойти ограничения языка
2. Проблемы с выравниванием памяти. Данный способ не гарантирует что память будет выравнена должным образом для всех членов UnixSocketImpl. Решение, которое не гарантирует полную переносимость, но все же работает в большинстве случаев – использование union:

[Источник](https://habr.com/ru/articles/111602/)

[Эффективный и современныи С++: 42 рекомендации по использованию С++ 11 и С++ 14 - Скотт Мейерс](Books/Эффективный_и_современный_С_Скотт_Мейерс.pdf) - Глава 4.5 c. 155