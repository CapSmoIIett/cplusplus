

Альтернативные имена стандартных атомарных типов и соответствующие им специализации std::atomic:

| Атомарный тип   | Соответствующая специализация atomic_bool std::atomic |
| --------------- | ----------------------------------------------------- |
| atomic_bool<br> | std::atomic bool                                      |
| atomic_char     | std::atomic cahr                                      |
| atomic_schar    | std::atomic signed char                               |
| atomic_uhar     | std::atomic unsigned char                             |
| atomic_int      | std::atomic int                                       |
| atomic_uint     | std::atomic unsigned                                  |
| atomic_short    | std::atomic short                                     |
| atomic_ushort   | std::atomic unsigned short                            |
| atomic_long     | std::atomic long                                      |
| atomic_ulong    | std::atomic unsigned long                             |
| atomic_llong    | std::atomic long long                                 |
| atomic_ullong   | std::atomic unsigned long long                        |
| atomic_char16_t | std::atomic char16_t                                  |
| atomic_char32_t | std::atomic char32_t                                  |
| atomic_wchar_t  | std::atomic wchar_t                                   |
Помимо основных атомарных типов, в стандартной библиотеке C++ определены также псевдонимы typedef для атомарных типов, соответствующих различным неатомарным библиотечным typedef, например std::size_t. 
Атомарный тип, соответствующий стандартному typedef T, имеет такое же имя с префиксом atomic_: atomic_T

Стандартные атомарные типы не допускают копирования и присваивания в обычном смысле, то есть не имеют копирующих конструкторов и операторов присваивания

операции разбиты на три категории . 
- Операции сохранения , для которых можно задавать упорядочение 
	- memory_order_relaxed, 
	- memory_order_release,
	- memory_order_seq_cst. 
- Операции загрузки , для которых можно задавать упорядочение 
	- memory_order_relaxed, 
	- memory_order_consume, 
	- memory_ order_acquire,
	- memory_order_seq_cst 
- Операции чтения-модификации-записи, для которых можно задавать упорядочение 
	- memory_order_relaxed, 
	- memory_ order_consume, 
	- memory_order_acquire, 
	- memory_order_ release, 
	- memory_order_acq_rel,
	- memory_order_seq_cst. 
По умолчанию для всех операций подразумевается упорядочение memory_order_seq_cst.

## std::atomic bool

Можно инициализировать с помощью true, false
Разрешено также присваивать объектам типа std::atomic bool

Что касается оператора присваивания с неатомарным bool в правой части, нужно еще отметить отход от общепринятого соглашения о возврате ссылки на объект в левой части – этот оператор возвращает присвоенное значение типа bool.

#### compare_exchange_weak() и compare_ exchange_strong()

Она сравнивает значение атомарной переменной с указанным ожидаемым значением и, если они совпадают, то сохраняет указанное новое значение

В случае compare_exchange_weak() сохранение может не произойти, даже если текущее значение совпадает с ожидаемым (Эта ситуация называется **ложным отказом**). В таком случае значение переменной не изменится, а функция вернет false. Такое возможно на машинах, не имеющих аппаратной команды сравнить-и-обменять, если процессор не может гарантировать атомарности операции – например, потому что поток, в котором операция выполнялась, был переключен в середине требуемой последовательности команд и замещен другим потоком (когда потоков больше, чем процессоров).

compare_exchange_strong() гарантированно возвращает false только в том случае, когда текущее значение не было равно ожидаемому (expected)

Если новое сохраняемое значение вычисляется просто, то выгоднее использовать compare_ exchange_weak(), чтобы избежать двойного цикла на платформах, где compare_exchange_weak() может давать ложный отказ (и, следовательно, compare_exchange_strong() содержит цикл)

Функции сравнения и обмена необычны еще и тем, что могут принимать два параметра упорядочения доступа к памяти. Это позволяет по-разному задавать семантику упорядочения в случае успеха и отказа. Если упорядочение для отказа не задано, то предполагается, что оно такое же, как для успеха, с тем отличием, что часть release заменяется: memory_order_release становится memory_order_relaxed, а memory_order_acq_rel – memory_order_acquire. Если не задано ни одно упорядочение, то как обычно предполагается memory_order_ seq_cst

### std::atomic T*

копирующие конструктор и оператор присваивания не определены, но разрешено конструирование и присваивание на основе подходящих указателей

арифметические операции fetch_add() и fetch_sub(). Возвращает текущиее значение и смещает указатель
### Операции над стандартными атомарными целочисленными типами

fetch_add(), fetch_sub(), fetch_and(), fetch_ or(), fetch_xor()

отсутствуют лишь операторы умножения, деления и сдвига, поскольку атомарные целочисленные значения обычно используются в качестве счетчиков или битовых масок, потеря не слишком велика, а в случае необходимости недостающие операции можно реализовать с помощью вызова функции compare_exchange_ weak() в цикле

### Основной шаблон класса std::atomic

Наличие основного шаблона позволяет создавать атомарные варианты пользовательских типов
Однако в качестве параметра шаблона std::atomic<> может выступать только тип, удовлетворяющий определенным условиям:
- в нем должен присутствовать *тривиальный* оператор присваивания.

Это означает, что в типе не должно быть виртуальных функций или виртуальных базовых классов, а оператор присваивания должен генерироваться компилятором. Более того, в каждом базовом классе и нестатическом члене данных также должен быть тривиальный оператор присваивания. Это позволяет компилятору использовать для присваивания функцию memcpy().

- тип должен допускать побитовое сравнение на равенство. Позволяет сравнивать их с помощью memcmp().


Если размер пользовательского типа UDT равен (или меньше) размеру int или void*, то на большинстве платформ для типа std::atomic можно сгенерировать код, содержащий только атомарные команды. На некоторых платформах подобный код можно сгенерировать и в случае, когда размер пользовательского типа в два раза превышает размер int или void*. Обычно это платформы, на которых имеется команда сравнения и обмена двойных слов doubleword-compare-and-swap (DWCAS), соответствующая функциям compare_exchange_xxx