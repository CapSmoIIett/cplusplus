std::unique_ptr делает все то же, что и std::auto_ptr, плюс еще кое-что. 
Он делает это максимально эффективно и безо всяких искажений понятия копирования объекта. 
Он во всех отношениях лучше std::auto_ptr. 

по умолчанию std::unique_ptr имеет тот же размер, что и обычный указатель, и для большинства
операций (включая разыменования) выполняются точно такие же команды.
(почти всегда работаю так же быстро и занимают столько же памяти как и обычные указатели)

**Испоnьзуйте std::unique_ptr дnя управления ресурсами путем исключительноrо владения**

Интеллектуальные указатели std::unique_ptr воплощают в себе семантику исключительного владения.

- Ненулевой std::unique_ptr всегда владеет тем, на что указывает. 
- Перемещение std::unique_ptr передает владение от исходного указателя целевому. (Исходный указатель при этом становится нулевым.) 
- Копирование std::unique_ptr не разрешается, так как если вы можете копировать std : : unique _ptr, то у вас их будут два

std::unique_ptr, указывающих на один и тот же ресурс, и каждый из них будет считать,
что именно он владеет этим ресурсом (а значит, должен его уничтожить).

**std::unique_ptr является только перемещаемым типом**

При деструкции ненулевой std::unique_ptr освобождает ресурс, которым владеет. 
По умолчанию освобождение ресурса выполняется с помощью оператора delete, примененного ко встроенному указателю в std::unique_ptr. 

Обычное применение std::unique_ptr - возвращаемый тип [[фабричных функций]]
для объектов иерархии.

В процессе конструирования объект std::unique_ptr можно настроить для использования пользовательских удалителей (custom deleters): 
произвольных функций (или функциональных объектов, включая получающиеся из лямбда-выражений), вызываемых
для освобождения ресурсов.

```c++
auto funForDelete = [](MyClass* a)
{
    doSomething(a);
    delete a;
}

std::unique_ptr<MyClass, decltype(funForDelete)> ptr(nullptr, funForDelete);
```

- funForDelete представляет собой пользовательский удалитель для объекта. 
Все функции пользовательских удалителей принимают обычный указатель на удаляемый объект и затем выполняют все необходимые действия по его удалению. 
Применение лямбда-выражения для создания funForDelete удобно, но, как вы вскоре увидите, оно также гораздо
эффективнее написания обычной функции. 
- Когда используется пользовательский удалитель, его тип должен быть указан
в качестве второго аргумента типа std::unique_ptr.
- Для связи пользовательского удалителя funForDelete с нашим указателем 
ptr мы передаем его в качестве второго аргумента конструктора.
- Попытка присвоить обычный указатель (например, возвращенный оператором new) указателю std::unique_ptr компилироваться не будет, поскольку она будет содержать неявное преобразование обычного указателя в интеллектуальный.  Такие неявные преобразования могут быть проблематичными, так что интеллектуальные указатели С++ 11 их запрещают. 

Для того, чтобы ptr взял на себя владение объектом, созданным с помощью оператора new, применяется вызов reset. 

```c++
ptr.reset(new Bond(std::forward<Data>(data)))
```

Если в std::unique_ptr используются пользовательские удалители, то в его размер увеличивается на слова-два (удалители - указатель на функцию)

Функциональные объекты без
состояний (например, получающиеся из лямбда-выражений без захватов) не приводят к увеличению размеров std::unique_ptr, а это означает что 
*когда пользовательский удалитель может быть реализован как функция или как лямбда-выражение, то реализация в виде лямбдавыражения предпочтительнее*

Удалители в виде функциональных объектов с большим размером состояния могут
привести к значительным размерам объектов std::unique _ptr. Если вы обнаружите, что пользовательский удалитель делает ваш интеллектуальный указатель std : : unique _ptr неприемлемо большим, вам, вероятно, стоит изменить свой дизайн. 

```c++
auto funForDel1 = [] (MyClass* plnvestment)
{                               // Пользовательский удалитель
makeLogEntry (plnvestment) ;    // как лямбда-выражение
delete plnvestment;             // без состояния
}; 
```

**std::unique_ptr часто используют для реализации [[pimpl]]

Интеллектуальный указатель std::unique_ptr имеет две разновидности: 
    - одну - для индивидуальных объектов (std::unique_ptr<>)
    - другую - для массивов (std::unique_ptr<T []>)
	
в случае указателя для одного объекта отсутствует оператор индексирования (operator [] ),  
в случае указателя для массива отсутствуют операторы разыменования (operator* и operator- >). 

Существование std::unique_ptr для массивов должно представлять только интеллектуальный интерес,  поскольку std::array, std::vector и std::string почти всегда оказываются лучшим выбором, чем встроенные массивы

Единственная ситуация, когда std::unique_ptr<T [] > имеет смысл - при использовании С-образного API, который возвращает встроенный указатель на массив в динамической памяти, которым вы будете владеть. 

std::unique_ptr можно легко и эффективно преобразовать в std::shared_ptr.  
Благодаря этому этот указатель хорошо подходит для возвращаемого типа фабричных функций.

- std::unique_ptr представляет собой маленький, быстрый, предназначенный только для перемещения интеллектуальный указатель для управления ресурсами с семантикой исключительного владения.
- По умолчанию освобождение ресурсов выполняется с помощью оператора delete, но могут применяться и пользовательские удалители. Удалители без состояний и указатели на функции в качестве удалителей увеличивают размеры объектов std::unique_ptr.
- Интеллектуальные указатели std::unique_ptr легко преобразуются в интеллектуальные указатели std::shared_ptr(обратное неверно)