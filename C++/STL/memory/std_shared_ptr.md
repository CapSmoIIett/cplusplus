Не может работать  с массивами ( и пробовать не стоит)

**Испопьзуйте std::shared_ptr дпя управпения ресурсами путем совместноrо владения**

Объект, доступ к которому осуществляется через указатели std::shared_ptr,  имеет время жизни, управление которым осуществляется этими указателями  посредством совместного владения. 

Когда последний указатель std::shared_ptr, указывающий на объект, прекратит на него 
указывать (например, из-за того, что этот std::shared_ptr будет уничтожен или перенаправлен на другой объект), этот std::shared_ptr уничтожит объект, на который он указывал.

В std::shared_ptr есть счетчик ссылок (не в нем а в блоке управления) - показывающий сколько std::shared_ptr указывает на один и тот же ресурс.

Конструкторы std::shared_ptr увеличивают этот счетчик (обычно увеличивают - см. ниже),  деструкторы std::shared_ptr уменьшают его, а операторы копирующего присваивания делают и то, и другое.

```c++
// sp1 и sp2 - std::shared_ptr указывающие на разные объекты.
// При: 
sp1 = sp2;

// sp1 - теперь указывает на ресурс sp2
// счетчик sp1 - уменьшается
// счетчик sp2 - увеличивается
```

Если std::shared_ptr после выполнения декремента видит нулевой счетчик ссылок, это означает, что на ресурс не указывает больше ни один std::shared_ptr, так что наш интеллектуальный указатель освобождает этот ресурс.

Особенности: 
- Размер std::shared_ptr в два раза больше размера обычноrо указателя, поскольку данный интеллектуальный указатель содержит обычный указатель на ресурс и другой обычный указатель на структуру данных в которой находится счетчик ссылок (стандарт не требует именно такой реализации, но в std сделано так)
- Память для счетчика ссылок должна выделяться динамически. (точнее для структуры данных в которой находится счетчик)  (Приятным следствием этого является то, что интеллектуальный указатель std::shared_ptr может работать с объектами любого типа (в том числе встроенных типов).)
- Инкремент и декремент счетчика ссылок должны быть атомарными, поскольку могут присутствовать одновременное чтение и запись в разных потоках. *Атомарные операции обычно медленнее неатомарных, так что несмотря на то, что обычно счетчики ссылок имеют размер в одно слово, следует рассматривать их чтение и запись как относительно дорогостоящие операции.*

**При вызове конструктора перемещения счетчик не изменяется.**  

Использование перемещающего конструктора std::shared_ptr, делает исходный указатель нулевым.

Старый указатель перестает указывать на ресурс в тот же момент как новый начинает это делать.

**Таким образом, перемещение std::shared_ptr оказывается быстрее копирования: копирование требует увеличения счетчика ссылок, а перемещение - нет.**
Это справедливо как для присваивания, так и для конструирования, так что перемещающее конструирование быстрее копирующего
конструирования, а перемещающее присваивание быстрее копирующего присваивания.

В отличии от std::unique_ptr тип удалителя не является частью типа интеллектуального указателя std::shared_ptr:
```c++
std::unique_ptr<Widget, decltype(funForDel)>    // Тип удалителя является
    upw (new Widget, funForDel);                // частью типа указателя

std::shared_ptr<Widget>                         // Тип удалителя не является
    spw (new Widget, funForDel);               // частью типа указателя
```

Следовательно дизайн std::shared_ptr более гибок
(можно разместить в контейнере std::shared_ptr указатели с различными удалителями, так же их можно без проблем присваивать один другому)

**Указание пользовательского удалителя не влияет на размер объекта std::shared_ptr.**
Независимо от удалителя объект std::shared_ptr имеет размер, равный размеру двух указателей.

std::shared_ptr - имеет указатель на данные и на управляющий блок в котором находится информация о счетчеке указателей,пользовательском удалителе, опционально пользовательский распределитель памяти

![указатели shared_ptr](images/shared_ptr_1.png)

Управляющий блок объекта настраивается функцией, создающей первый указатель std::shared_ptr на объект.
При создании управляющего блока должны использоваться следующие правила:
- Функция std::make_shared всегда создает управляющий блок. Она производит новый объект, на который будет указывать интеллектуальный указатель, так что в момент вызова std::make_shared управляющий блок для этого объекта, определенно, не существует.
- Управляющий блок создается тогда, когда указатель std::shared_ptr создается из указателя с исключительным владением (т.е. std::unique_ptr или std::auto_ptr). Указатели с исключительным владением не используют управляющие блоки, так что никакого управляющего блока для указываемого объекта не существует. (Как часть своего построения std::shared_ptr осуществляет владение указываемым объектом, так что указатель с исключительным владением становится нулевым.) 
	- Когда конструктор std::shared_ptr вызывается с обычным указателем, он создает управляющий блок.

(Если вы хотите создать std::shared_ptr из объекта, у которого уже имеется управляющий блок, вы предположительно передаете в качестве аргумента конструктора std::shared_ptr или std::weak_ptr)

создание более одного std::shared_ptr из единственного обычного указателя  - ведет к неопределенному поведению.

Старайтесь не передавать обычные указатели в shared_ptr, если без этого не как, то передавайте сразу результа *new*, а не обычную переменную.

С make_shared нельзя задать удалители.

управляющий блок - размером в несколько слов (пользовательские удалители и распределители могут его увеличить)
(по  умолчанию при создании с помощью make_shared - около 3-х слов)

взаимодействие со счетчиком - 1/2 атомарные операции.

Обычно реализация управляющего блока применяет наследование и имеет виртуальные функции ( для коректного уничтожения) -  это все то же увеичивает стоимость std::shared_ptr.

**std::shared_ptr - не лучший способ управления ресурсами!**
*Но его функицонал/стоимость очень приятна*

[[std_shared_ptr и this]]

- std::shared_ptr предоставляет удобный подход к управлению временем жизни произвольных ресурсов, аналогичный сборке мусора.
- По сравнению с std::unique_ptr объекты std::shared_ptr обычно в два раза больше, привносят накладные расходы на работу с управляющими блоками и требуют атомарной работы со счетчиками ссылок.
- Освобождение ресурсов по умолчанию выполняется с помощью оператора delete, однако поддерживаются и пользовательские удалители. Тип удалителя не влияет на тип указателя std::shared_ptr.
- Избегайте создания указателей std::shared_ptr из переменных, тип которых - обычный встроенный указатель. 