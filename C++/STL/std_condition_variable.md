std::condition_variable и std::condition_variable_any,
один работает только с mutex, другой со всеми классами которые отвечают требованиям подобия mutex-у

принимает [[std_mutex]] под которым проходи взаимодействие с нужными данными и условие, которое проверяется при получении сообщения


```c++
std::condition_variable cond_var;
std::mutex mut;

{ // Первый поток
    // ...
    std::lock_guard<std::mutex> lock(mut);
    cond_var.notify_one();  // говорим условной переменной, что нужно проверить условие 
    // ...
}

{ // Второй поток

    std::unique_lock<std::mutex> lock(mut); 
    data_cond.wait( lock,[]{return /*условие*/;});  // При получении нотификации проверяет условие, если условие true продолжает выполнение
    // Внутри wait() условная переменная может проверять условие многократно, но всякий раз это делается после захвата мьютекса
    // ...
}
```

Поток, намеревающийся изменить общую переменную, должен:
1. Получить [[std_mutex]] обычно через std::lock_guard ).
2. Измените общую переменную, пока блокировка находится в собственности.
3. Вызовите notify_one или notify_all на `std::condition_variable`(можно сделать после снятия блокировки).


любой поток, который намерен ждать, `std::condition_variable`должен:
1. Получите std:: unique_lock<std:: mutex> для мьютекса, используемого для защиты общей переменной.
2. Выполните одно из следующих действий:
	1. Проверьте состояние, возможно, оно уже обновлено и об этом сообщено.
	2. Вызовите wait, wait_for или wait_until для `std::condition_variable`(атомарно освобождает мьютекс и приостанавливает выполнение потока до тех пор, пока не будет получено уведомление от условной переменной, не истечет тайм-аут или не произойдет ложное пробуждение , а затем атомарно захватывает мьютекс перед возвратом).
	3. Проверьте условия и возобновите ожидание, если они вас не устраивают.
или:
	1. Используйте предикатную перегрузку wait , wait_for и wait_until , которая выполняет те же три шага.