std::async позволяет запустить асинхронную задачу, результат которой прямо сейчас не нужен

std::async не гарантирует создание нового программного потока (если использовать флаг - std::launch::async, то отдельный поток гарантируется)

Стратегии выполнения std::async:
- std::launch::async - должна выполняться в другом потоке
- std::launch::deffered - вызов откладывается до вызова метода get() или wait();

Нет стратегии по умолчанию. Если стратегия не указанна то она выбирается компонентом управления потоками. Из за этоого нельзя точно сказать будет ли выполнен std::async паралельно, каким потоком будет выполняться и будет ли выполнен вообще.

Стратегию по умалчанию стоит использовать при выполнении следующих условий (учет стратегии deffered):
 - Задача не обязана работать параллельно с потоком, вызывающим get или wait.
 - Не имеет значения, переменные thread_local какого потока читаются или записываются.
 - Либо гарантируется вызов get или wait для фьючерса, возвращаемого std::async,
либо ситуация, когда задача не выполняется совсем, является приемлемой.
 - Код с использованием wait_for или wait_until учитывает возможность отложенного состояния задачи. 

Если функция, вызванная через std::async, возбуждает исключение, то это исключение сохраняется в будущем результате вместо значения, а когда будущий результат оказывается готовым, вызов get() повторно возбуждает сохраненное исключение. (Примечание: стандарт ничего не говорит о том, возбуждается ли исходное исключение или его копия; различные компиляторы и библиотеки вправе решать этот вопрос поразному.)