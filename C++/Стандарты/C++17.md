не все дополняния, но крайне полезные

[источник](https://habr.com/ru/articles/343622/)
#### 1. Декомпозиция при объявлении

"структурные привязки" (structural bindings), позволяющая разбивать структуры или кортежи на отдельные переменные:

```c++
struct BookInfo
{    
	std::string title; // In UTF-8    
	int yearPublished = 0;
};

auto [title, year] = readBookInfo();
auto [iterator1, succeed1] = map.try_emplace("key", "abc");
```

Ограничения:
- нельзя явно указывать типы декомпозируемых элементов
- нельзя использовать вложенную декомпозицию вида `auto [title, [header, content]]`

#### 2. Автоматический вывод параметров шаблонов

Ключевые правила:
- функции вида `std::make_pair` больше не нужны: смело пишите выражения `std::pair{10, "hello"s}`, компилятор сам выведет тип
- шаблонные RAII вида `std::lock_guard<std::mutex> guard(mutex);` станут короче: `std::lock_guard guard(mutex);`
- функции `std::make_unique` и `std::make_shared` по-прежнему нужны

#### 3. Объявление вложенных пространств имён

Избегайте вложенности пространств имён, а если не избежать, то объявляйте их так:

``` c++
namespace product::account::details
{
	// ...ваши классы и функции...
}
```

  
#### 4. Атрибуты nodiscard, fallthrough, maybe_unused

Ключевые правила:
- завершайте все блоки case, кроме последнего, либо атрибутом `[[fallthrough]]`, либо инструкцией `break;`

```c++
enum class option { A, B, C };

void choice(option value)
{    
	switch (value)    
	{    
	case option::A:        
		// ...    
	case option::B: // warning: unannotated fall-through between              
					//          switch labels        
		// ...        
		[[fallthrough]];    
	case option::C: // no warning        
		// ...        
		break;    
	}
}
```
- используйте `[[nodiscard]]` для функций, возвращающих код ошибки или владеющий указатель (неважно, умный или нет)

```c++
[[nodiscard]] std::unique_ptr<Bitmap> LoadArrowBitmap() { /* ... */ }

void foo()
{    
	// warning: ignoring return value of function declared    
	//          with warn_unused_result attribute    
	LoadArrowBitmap();  
}
```

Если вы используете, например, свой класс ошибок, то вы можете указать атрибут единожды в его объявлении.

```c++
class [[nodiscard]] error_code { /* ... */ };
```

- используйте `[[maybe_unused]]` для переменных, которые нужны только для проверки в assert

Иногда программисты создают переменную, используемую только в отладочной версии для хранения кода ошибки вызванной функции. Возможно, это просто ошибка дизайна кода, и возвращаемое значение следовало обрабатывать всегда. Тем не менее:

```c++
// ! старый код !
auto result = DoSystemCall();
(void)result; // гасим предупреждение об unused variable
assert(result >= 0);

// современный код
[[maybe_unused]] auto result = DoSystemCall();
assert(result >= 0);
```
#### 5. Класс string_view для параметров-строк

Правила:
- в параметрах всех функций и методов вместо `const string&` старайтесь принимать невладеющий `string_view` по значению  
    - возвращайте из функций и методов владеющий `string`, как и раньше
- будьте осторожны с возвратом string_view из функции: это может привести к проблеме висячих ссылок (англ. dangling pointers)

Класс `string_view` хорош тем, что он легко конструируется и из `std::string` и из `const char*` без дополнительного выделения памяти. А ещё он имеет поддержку constexpr и повторяет интерфейс std::string. Но есть минус: для `string_view` не гарантируется наличие нулевого символа на конце.

#### 6. Классы optional и variant

Применение `optional<>` и `variant<>` настолько широко, что я даже не буду пытаться полностью описать их в этой статье. Ключевые правила:
- предпочитайте `optional<T>` вместо `unique_ptr<T>` для композиции объекта T, время жизни которого короче времени жизни владельца  
    - для PIMPL используйте `unique_ptr<Impl>`, потому что определение Impl скрыто в файле реализации класса
- используйте тип variant вместо enum или полиморфных классов в ситуации, когда состояния, такие как состояние лицензии, не могут быть описаны константами enum из-за наличия дополнительных данных в каждом из состояний
- используйте тип variant вместо enum в ситуации, когда данные, такие как код ошибки в исключении, должны быть обработаны во всех вариантах, и неполная обработка вариантов должна приводить к ошибке компиляции
- используйте тип variant вместо any везде, где это возможно
- не применяйте `optional` для обработки ошибок: он не несёт никакой информации об ошибке  
    - для возврата значения либо ошибки можно написать свой класс `Expected<Value, Error>`, основанный на `boost::variant<...>`
    - а можно не писать и взять готовый: [github.com/martinmoene/expected-lite](https://github.com/martinmoene/expected-lite)

```
// nullopt - это специальное значение типа nullopt_t, которое сбрасывает
//  значение optional (аналогично nullptr для указателей)std::optional<int> optValue = std::nullopt;// ... инициализируем optValue ...// забираем либо значение, либо -1const int valueOrFallback = optValue.value_or(-1);
```