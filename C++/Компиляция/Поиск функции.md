Компилятор выбирает перегруженную функцию для вызова на основе наилучшего соответствия между объявлениями функций в текущей области с аргументами, указанными в вызове функции. Если подходящая функция найдена, эта функция вызывается. 

Этот этап называется разрешением перегрузки (overload resolution). Если такая функция найдена, то разрешение перегрузки завершается успешно, иначе возникает ошибка (ambiguous call to overloaded function).

"Подходит" в этом контексте означает:

[Источник](https://learn.microsoft.com/ru-ru/cpp/cpp/function-overloading?view=msvc-170)
#### 1.  Точное соответствие найдено

Когда типы аргументов, переданных при вызове функции, точно совпадают с типами параметров одной из перегруженных функций.




```c++
void print(int x) { std::cout << "Printing int: " << x; } 
void print(double x) { std::cout << "Printing double: " << x; } 

int main() 
{ 
	print(42); // Точное соответствие для void print(int x) return 0; 
}
```

#### 1.1 Области видимости 

Если в текущей области видимости нет ни одной функции с искомым именем, текущей областью видимости становится объемлющая область видимости. Но, если в текущей области видимости найдена хотя бы одна функция с искомым именем, то выполняется разрешение перегрузки в данной области видимости и объемлющая область видимости рассматриваться не будет.

Области видимости распространяются и на классы. Сначала поиск проходит в текущем классе, после в родителях. 

```c++
class B
{
public:
    void Foo(int x) { std::cout << "int"; }
};

class D : public B
{
public:
    void Foo(double x) { std::cout << "double"; }
};

int main()
{
	D d;
	d.Foo(42);
}
```

! Если метод `Foo` в классе `D` объявить закрытым  или защищенным или удаленным, то компиляция завершится ошибкой.
И только, если из класса `D` совсем убрать `Foo`, то компилятор сделал бы текущей областью видимости класс `B` и выбрал бы `B::Foo(int)`.

#### 1.2 Локальное объявление функций

Рассмотрим теперь одну редко используемую особенность C++, которая называется локальные объявления функций.

```c++
void Foo(double x) { std::cout << "double"; }
void Foo(int x) { std::cout << "int"; }

int main()
{
    void Foo(double x);
    Foo(42);
}
```

Функции, объявленные локально, должны быть определены в глобальном пространстве имен, локальные определения в C++ не разрешены.

Если функция вызывается в блоке без дополнительных квалификаторов класса или пространства имен, то текущей областью видимости, в которой происходит разрешение перегрузки, будет этот блок. Если в блоке есть локальные объявления функций, то одноименные функции из объемлющих областей видимости будут скрыты.

#### 1.3   Расширение области видимости

[[область видимости]]

Область видимости для разрешения перегрузки можно расширить с помощью `using`-объявления и `using`-директивы. Также, в определенном случае, компилятор самостоятельно расширяет область видимости для разрешения перегрузки.

##### 1.3.1 Использования using-объявления в классе

```c++

class B
{
public:
    void Foo(int x) { std::cout << "int"; }
};

class D : public B
{
public:
    using B::Foo;
    void Foo(double x) { std::cout << "double"; }
};

int main()
{
	D d;
	d.Foo(42);
}

```

После этого в разрешении перегрузки будут участвовать перегруженные `Foo` из области видимости класса `B`, и компилятор выберет `B::Foo(int)`

##### 1.3.2 Использования using-объявления локально и в пространстве имен

`using`-объявления с использованием имени пространства имен перекрывают  соответствующие имена из объемлющей области видимости.

```c++
#include <iostream>

namespace N
{
    void Foo(int x) { std::cout << "int"; };
}

void Foo(const char* x) { std::cout << "char*"; };

int main()
{
 using N::Foo; // скрывает Foo(const char*)
    Foo(42);      // OK, N::Foo(int x)
    Foo("meow");  // ошибка, Foo(const char*) скрыта
}
```

В данном случае, для того чтобы обе версии `Foo` участвовали в разрешении перегрузки, `using`-объявление надо размещать так:

```c++
namespace N
{
    void Foo(int x) { std::cout << "int"; };
}

void Foo(const char* x) { std::cout << "char*"; };

using N::Foo;
int main()
{
    Foo(42);      // OK, N::Foo(int)
    Foo("meow");  // OK, Foo(const char*)
}

```

#### 1.3.3 Использования using-директивы

Пусть у нас есть некоторое пространство имен `N`. Инструкция  
```c++
using namespace N;
```
называется `using`-директивой. В области ее видимости можно использовать имена из пространства имен `N` без квалификатора `N::`. При разрешении перегрузки также будут участвовать функции из `N`, то есть `using`-директива приводит к расширению области видимости для разрешения перегрузки (и, в отличии от `using`-объявления, ничего не скрывает).

Если используется анонимное пространство имен, то функции, объявленные в нем, будут участвовать в разрешении перегрузки вместе с одноименными функциями, объявленными в объемлющем пространстве имен. (Фактически анонимное пространство имен доступно через скрытую `using`-директиву.)

```c++
namespace 
{
    void Foo(int x) { std::cout << "int"; };
}

void Foo(const char* x) { std::cout << "char*"; };

int main()
{
    Foo(42);      // OK, N::Foo(int)
    Foo("meow");  // OK, Foo(const char*)
}
```
#### 1.3.4 Поиск, зависимый от типа аргументов

Есть одна ситуация, когда компилятор самостоятельно расширяет текущую область видимости для разрешения перегрузки. Рассмотрим объявление класса и функции в некотором пространстве имен:

```c++
namespace N
{
    class X {/* ... */};
    void Foo(const X& x) { std::cout << "x"; };;
}

int main()
{
    N::X x;
    Foo(x);
}
```

В этом случае при разрешении перегрузки компилятор подключит пространство имен `N` и, если не будет конфликта с текущей областью видимости, будет выбрана `N::Foo(const X&)`. Это и называется поиском, зависимым от типа аргументов ([[Argument depended lookup]], ADL), называемый еще поиском Кёнига. ADL играет важную роль при перегрузке операторов, функций стандартной библиотеки и в других случаях.
#### 2. Выполнение тривиального преобразования 

 Тривиальные преобразования включают преобразования между:
- ссылками или указателями на один и тот же тип.
- преобразования между `bool` и целыми типами.

```c++
void print(const int& x) { std::cout << "Printing const int&: " << x ; } 

int main() 
{ 
	int x = 42; 
	print(x); // Тривиальное преобразование для const int& 
	return 0; 
}
```

#### 3. Восходящее приведение целого типа

Восходящее преобразование целого типа означает преобразование меньшего целого типа в больший, например, `char` в `int`.

```c++
void print(int x) { std::cout << "Printing int: " << x; } 

int main() 
{ 
	char c = 'a'; 
	print(c); // Восходящее преобразование char в int 
	return 0; 
}
```

#### 4. Существует cтандартное преобразование в требуемый тип аргумента 

Стандартные преобразования включают преобразования между числовыми типами, такими как `float` в `double`, или между указателями и `void*`.

```c++
void print(double x) { std::cout << "Printing double: " << x; } 

int main() 
{ 
	float f = 3.14f; 
	print(f); // Стандартное преобразование float в double 
	return 0; 
}
```

#### 5.  Существует определенное пользователем преобразование (оператор преобразования или конструктор) в нужный тип аргумента 

Это включает использование конструкторов или операторов преобразования, определенных пользователем, для преобразования одного типа в другой.

```c++
class MyClass 
{ 
public: 
	MyClass(int x) 
	{ std::cout << "MyClass constructed with int: " << x; } 
}; 

void print(MyClass obj) { std::cout << "Printing MyClass"; } 

int main() 
{ 
	print(42); // Определяемое пользователем преобразование int в MyClass 
	return 0; 
}
```

#### 6. Аргументы, представленные многоточием

Это относится к использованию функций с переменным числом аргументов, где многоточие (`...`) позволяет передавать любое количество аргументов.

[[Переменное число параметров функции]]

```c++
#include <cstdarg> 

void print(int count, ...) 
{ 
	va_list args; 
	va_start(args, count); 
	for (int i = 0; i < count; ++i) 
	{ 
		std::cout << va_arg(args, int) << " "; 
	} 
	va_end(args); 
} 

int main() 
{ 
	print(3, 1, 2, 3); // Аргументы, представленные многоточием 
	return 0; 
}
```

#### 7. Принцип SFINAE

Substitution Failure is not an Error (сбой при подстановке не является ошибкой)

```c++
template<typename T>
void Foo(const T* x);

Foo(42);
```


#### 8. Cпециализаций шаблонов

[[Шаблоны]]

```c++

#include <iostream>

// нешаблонная функция
void Foo(int x) { std::cout << "Foo(int x) " << x << "\n"; }

// шаблон 1
template<typename T>
void Foo(T x) { std::cout << "Foo(T x) " << x << "\n"; } 
// полная специализация шаблона 1 для double
template<>
void Foo<double>(double x) { std::cout << "Foo<double>(double x) " << x << "\n"; }
// полная специализация шаблона 1 для const char*
template<>
void Foo<const char*>(const char* x) { std::cout << "Foo<const char*>(const char* x) " << x << "\n"; } 

// шаблон 2, более специализированный чем шаблон 1
template<typename T>
void Foo(const T* x) { std::cout << "Foo(const T* x) " << x << "\n"; } 

// шаблон 3, более специализированный чем шаблон 1
template<typename T>
class U { public: int a;};
template<typename T>
void Foo(U<T> u) { std::cout << "Foo(U<T> u) " << x.a << "\n"; }; 

//

int main()
{
    Foo(42);       // #1 — нешаблонная функция
    Foo(3.14);     // #2 — полная специализация шаблона 1 для double
    Foo(42L);      // #3 — конкретизация шаблона 1 для long
    Foo("meow");   // #4 — конкретизация шаблона 2 для char
    Foo(U<int>()); // #5 — конкретизация шаблона 3 для int
}
```