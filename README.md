# С++

Этот репозиторий представляет мою базу знаний по С++

В качестве его основы я взял эти карты:  
- [roadmap](https://github.com/salmer/CppDeveloperRoadmap)
- [карта ЛР](https://habr.com/ru/specials/726724/)

# Содержание:

- [Синтаксис](#синтаксис)
    - [Базовые операции](#базовые-операции)
        - [Арифметические операции](#арифметические-операции)
        - [Логические операции](#логические-операции)
        - [Циклы](#циклы)
        - [По битовые операции](#по-битовые-операции)
    - [Идиомы](#идиомы)
    - [Указатели и ссылки](#указатели-и-ссылки)
        - [Ссылки] (#ссылки)
        - [Умные казатели](#умные-казатели)
            - [std::auto_ptr](#stdаutо_ptr)
            - [std::unique_ptr](#stdunique_ptr)
            - [std::shared_ptr](#stdshared_ptr)
            - [std::make_unique и std::make_shared против new](#stdmake_unique-и-stdmake_shared-против-new)
        - [Row указатели](#row-указатели-сырые-или-обычные)
    - [Стандарты](#стандарты)
        - [C++98](#c98)
        - [C++11](#c11)
        - [C++14](#c14)
        - [C++17](#c17)
        - [C++20](#c20)
- [ООП](#ооп)
- [Патерны](#патерны)
    - [Порождающие](#порождающие)
        - [Фабричный метод](#фабричный-метод)
    - [Структурные](#структурные)
- [По битовые операции](#по-битовые-операции)
- [STL](#STL)
- [Системы сборки](#системы-сборки)
    - [Make](#make)
    - [CMake](#cmake)
- [Контроль версий (Git)](#контроль-версий-git)
- [Многопоточность](#многопоточность)
- [Сети](#сети)
    - [OSI](#osi)
    - [TCP](#tcpip)
    - [UDP](#udp)
    - [Win socket](#win-socket)
- [ОС](#ос)
    - [Жизнь программы](#жизнь-программы)

![карта с++](https://github.com/CapSmoIIett/cplusplus/blob/main/images/%D0%9A%D0%B0%D1%80%D1%82%D0%B0%20%D0%A1%2B%2B.png)  

![карта LK](https://github.com/CapSmoIIett/cplusplus/blob/main/images/roadmapLK.png)


# Синтаксис

## Базовые операции 

### Арифметические операции

#### Инкремент и декремент

Префиксный - увеличивает значение до выполенения кода в строке где его вызвали.  
Постфиксный - после выполнения кода в строке в которой его вызвали.
```diff
! Постфиксный немного медленее т.к. возвращает копию переменой которую инкрементировал.
```
[Источник](https://www.cyberforum.ru/cpp-beginners/thread1297462.html)

Операторы могут быть *левоассоциативными* - выполняются слева направо и *правоассоциативными* - выполняются справа налево.  
Большинство операторов левоассоциативны.   
Правоассоциативными операторами являются все унарные операторы, различные операторы присваивания и условный оператор.
  
---

### Логические операции 

---

### Циклы

---

### По битовые операции 

\<< сдвиг влево  
\>> сдвиг вправо  
\~ поразрядная инверсия  
\| поразрядное ИЛИ  
\& поразрядное И  
\^ поразрядное исключающее ИЛИ  

Если нужно записывать определенные биты, не стирая другие:

Чтобы записать единицу в бит n:
```c++
x |= (1 << n);
```

Чтобы записать ноль в бит n:
```c++
x &= ~(1 << n);
```

Если нужно инвертировать состояние бита:
```c++
x ^= (1 << n);
```

Если нужно прочитать отдельный бит:
```c++
unsigned char x = (1 << 2) | (1 << 3) | (1 << 7);  
if (x & (1 << 2)) {  /* во второй бит вписана единица */ }  
if (x & (1 << 3)) {  /* в третий бит вписана единица */ }  
if (x & (1 << 7)) {  /* в седьмой бит вписана единица */ }  
```

Если нужно определить, что в X на N-й позиции:
```c++
bool b = (bool((1 << n)  &  x))
```

Если нужно обнулить один или несколько битов:
```c++
int x = 58;       // 00111010
int y = x & 0x0F; // 00001010

//или

x = x & (~((1<<3)|(1<<5)|(1<<6))); //обнуляем третий, пятый и шестой биты
```

Если нужно установить заданные биты в единицу. Используют оператор |
```c++
int x = 155
x = x | 4;     //устанавливаем в единицу второй бит переменной x
```

Сдвигает число на n разрядов влево
```c++
unsigned char x = 3;  //0b00000011
x = x << 3;           //0b00011000 (24)
```

Сдвиг вправо >>
```c++
unsigned char x = 255;  //0b11111111
x = x >> 3;             //0b00011111 (31)
```

[Источник](https://volstr.ru/?p=36)

---

## Функции

## Типы данных
## Указатели и ссылки
### Ссылки
### Умные казатели 

[Эффективный и современныи С++: 42 рекомендации по использованию С++ 11 и С++ 14 - Скотт Мейерс](https://github.com/CapSmoIIett/cplusplus/blob/main/Books/%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%B8_%D1%81%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%A1_%D0%A1%D0%BA%D0%BE%D1%82%D1%82_%D0%9C%D0%B5%D0%B9%D0%B5%D1%80%D1%81.pdf) - Глава 4

Интеллектуальные указатели представляют собой оболочки вокруг встроенных указателей, 
которые действуют так же, как и встроенные указатели, но позволяют избежать
многих связанных с последними ловушек. *Поэтому вы должны предпочитать встроенным указателям интеллектуальные*

В С++11 имеются четыре интеллектуальных указателя: 
    - std::аutо_ptr,
    - std::unique_ptr, 
    - std::shared_ptr,
    - std::weak_ptr. 

По производительности:
-raw
-std::unique_ptr
-std::shared_ptr

#### std::аutо_ptr

Является устаревшим указателем, доставшимся в наследство от [С++98](#c98). 
В [С++11](#c11) его заменил std::unique_ptr.

В [С++98](#c98) небыло семантики перемещения, необходимой для std::аutо_ptr. 
Поэтому в std::аutо_ptr превратили операцию копирования в перемещение.
А это привело кк тому, что при копировании std::аutо_ptr он становился равен = nullptr.

Единственный случай обоснованного применения std::auto_ptr - необходимость компиляции
кода компилятором [С++98](#c98). Если у вас нет такого ограничения, вы должны заменять
std::auto_ptr указателем std::unique_ptr.

### std::unique_ptr

std::unique_ptr делает все то же, что и std::auto_ptr, плюс еще кое-что. 
Он делает это максимально эффективно и безо всяких искажений понятия копирования объекта. 
Он во всех отношениях лучше std::auto_ptr. 

по умолчанию std::unique_ptr имеет тот же размер, что и обычный указатель, и для большинства
операций (включая разыменования) выполняются точно такие же команды.
(почти всегда работаю так же быстро и занимают столько же памяти как и обычные указатели)

**Испоnьзуйте std::unique_ptr дnя управnения ресурсами путем искnючитеnьноrо впадения**

Интеллектуальные указатели std::unique_ptr воплощают в себе семантику исключительного владения.

- Ненулевой std::unique_ptr всегда владеет тем, на что указывает. 
- Перемещение std::unique_ptr передает владение от исходного указателя целевому. (Исходный указатель при этом становится нулевым.) 
- Копирование std::unique_ptr не разрешается, так как если вы можете копировать std : : unique _ptr, то у вас будут два
std::unique_ptr, указывающих на один и тот же ресурс, и каждый из них будет считать,
что именно он владеет этим ресурсом (а значит, должен его уничтожить).

**std::unique_ptr является только перемещаемым типом**

При деструкции ненулевой
std::unique_ptr освобождает ресурс, которым владеет. 
По умолчанию освобождение ресурса выполняется с помощью оператора de lete, примененного ко встроенному указателю
в std::unique_ptr. 

Обычное применение std::unique_ptr - возвращаемый тип [фабричных функций](#фабричный-метод) 
для объектов иерархии.

В процессе конструирования объект std::unique_ptr можно настроить для использования пользовательских удалителей (custom deleters): 
произвольных функций (или функциональных объектов, включая получающиеся из лямбда-выражений), вызываемых
для освобождения ресурсов.

```c++
auto funForDelete = [](MyClass* a)
{
    doSomething(a);
    delete a;
}

std::unique_ptr<MyClass, decltype(funForDelete)> ptr(nullptr, funForDelete);
```

- funForDelete представляет собой пользовательский удалитель для объекта. 
Все функции пользовательских удалителей принимают обычный указатель на удаляемый объект и затем выполняют все необходимые действия по его удалению. 
Применение лямбда-выражения для создания funForDelete удобно, но, как вы вскоре увидите, оно также гораздо
эффективнее написания обычной функции. 
- Когда используется пользовательский удалитель, его тип должен быть указан
в качестве второго аргумента типа std::unique_ptr.
- Для связи пользовательского удалителя funForDelete с нашим указателем 
ptr мы передаем его в качестве второго аргумента конструктора.
- Попытка присвоить обычный указатель (например, возвращенный оператором new)
указателю std::unique_ptr компилироваться не будет, поскольку она будет содержать неявное преобразование обычного указателя в интеллектуальный. 
Такие неявные преобразования могут быть проблематичными, так что интеллектуальные указатели С++ 11 их запрещают. 
Для того, чтобы ptr взял на себя владение объектом, созданным с помощью оператора new, применяется вызов reset. 
```c++
ptr.reset(new Bond(std::forward<Data>(data)))
```

Если в std::unique_ptr используются пользовательские удалители, то в его размер увеличивается на слова-два (удалители - указатель на функцию)

Функциональные объекты без
состояний (например, получающиеся из лямбда-выражений без захватов) не приводят
к увеличению размеров std::unique_ptr, а это означает что 
*когда пользовательский удалитель может быть реализован как функция или как лямбда-выражение, то реализация в виде лямбдавыражения предпочтительнее*

Удалители в виде функциональных объектов с большим размером состояния могут
привести к значительным размерам объектов std::unique _ptr. Если вы обнаружите, что
пользовательский удалитель делает ваш интеллектуальный указатель std : : unique _ptr
неприемлемо большим, вам, вероятно, стоит изменить свой дизайн. 

```c++
auto funForDel1 = [] (MyClass* plnvestment)
{                               // Пользовательский удалитель
makeLogEntry (plnvestment) ;    // как лямбда-выражение
delete plnvestment;             // без состояния
}; 
```

**std::unique_ptr часто используют для реализации [pimpl](#pimpl)**

Интеллектуальный указатель std::unique_ptr имеет две разновидности: 
    - одну - для индивидуальных объектов (std::unique_ptr<T>)
    - другую - для массивов (std::unique_ptr<T []>)

в случае указателя для одного объекта отсутствует оператор индексирования (operator [] ),  
в случае указателя для массива отсутствуют операторы разыменования (operator* и operator- >). 

Существование std::unique_ptr для массивов должно представлять только интеллектуальный интерес, 
поскольку std::array, std::vector и std::string почти всегда
оказываются лучшим выбором, чем встроенные массивы

Единственная ситуация, когда std::unique_ptr<T [] > имеет смысл - при использовании С-образного
API, который возвращает встроенный указатель на массив в динамической памяти, которым вы будете владеть. 

std::unique_ptr можно легко и эффективно преобразовать в std::shared_ptr.  
Благодаря этому этот указатель хорошо подходит для возвращаемого типа фабричных функций.

- std::unique_ptr представляет собой маленький, быстрый, предназначенный
только для перемещения интеллектуальный указатель для управления ресурсами
с семантикой исключительного владения.
- По умолчанию освобождение ресурсов выполняется с помощью оператора delete,
но могут применяться и пользовательские удалители. Удалители без состояний
и указатели на функции в качестве удалителей увеличивают размеры объектов
std::unique_ptr.
- Интеллектуальные указатели std::unique_ptr легко преобразуются в интеллектуальные указатели std::shared_ptr(обратное неверно)

---

### std::shared_ptr

Не может работать  с массивами ( и пробовать не стоит)

**Испопьзуйте std::shared_ptr дпя управпения ресурсами путем совместноrо владения**

Объект, доступ к которому осуществляется через указатели std::shared_ptr, 
имеет время жизни, управление которым осуществляется этими указателями 
посредством совместного владения

Когда последний указатель std::shared_ptr, указывающий на объект, прекратит на него 
указывать (например, из-за того, что этот std::shared_ptr будет уничтожен или перенаправлен
на другой объект), этот std::shared_ptr уничтожит объект, на который он указывал.

В std::shared_ptr есть счетчик ссылок - показывающий сколько std::shared_ptr указывает на один и тот же ресурс.

Конструкторы std::shared_ptr увеличивают этот счетчик (обычно увеличивают - см. ниже),  
деструкторы std::shared_ptr уменьшают его,  
а операторы копирующего присваивания делают и то, и другое.

```c++
// sp1 и sp2 - std::shared_ptr указывающие на разные объекты.
// При: 
sp1 = sp2;

// sp1 - теперь указывает на ресурс sp2
// счетчик sp1 - уменьшается
// счетчик sp2 - увеличивается
```

Если std::shared_ptr после выполнения декремента видит нулевой счетчик
ссылок, это означает, что на ресурс не указывает больше ни один std::shared_ptr, так
что наш интеллектуальный указатель освобождает этот ресурс.

Особенности: 
- Размер std::shared_ptr в два раза больше размера обычноrо указателя, поскольку данный интеллектуальный указатель
содержит обычный указатель на ресурс и другой обычный указатель на структуру данных в которой находится счетчик ссылок
(стандарт не требует именно такой реализации, но в std сделано так)
- Память для счетчика ссылок должна выделяться динамически. (точнее для структуры данных в которой находится счетчик) 
(Приятным следствием этого является то, что интеллектуальный указатель std::shared_ptr может работать с объектами любого типа (в том числе встроенных типов).)
(далее будет описан способ как можно избежать динамческого выделения с помощью std::make_shared)
- Инкремент и декремент счетчика ссылок должны быть атомарными, поскольку
могут присутствовать одновременное чтение и запись в разных потоках.
*Атомарные операции обычно медленнее неатомарных, так что несмотря на то, что обычно счетчики ссылок имеют размер в одно слово, следует рассматривать их чтение и запись как относительно дорогостоящие операции.*

**При вызове конструктора перемещения счетчик не изменяется.**  
Использование перемещающего конструктора std::shared_ptr, делает исходный указатель нулевым.
Старый указатель перестает указывать на ресурс в тот же момент как новый начинает это делать.
**Таким образом, перемещение std::shared_ptr оказывается быстрее копирования: копирование требует увеличения счетчика ссылок, а перемещение - нет.**
Это справедливо как для присваивания, так и для конструирования, так что перемещающее конструирование быстрее копирующего
конструирования, а перемещающее присваивание быстрее копирующего присваивания.

В отличии от std::unique_ptr тип удалителя не является частью типа интеллектуального указателя std::shared_ptr:
```c++
std::unique_ptr<Widget, decltype(funForDel)>    // Тип удалителя является
    upw (new Widget, funForDel);                // частью типа указателя

std::shared_ptr<Widget>                         // Тип удалителя не является
    spw (new Widget, funForDel);               // частью типа указателя
```
Следовательно дизайн std::shared_ptr более гибок
(можно разместить в контейнере std::shared_ptr указатели с различными удалителями, так же их можно без проблем присваивать один другому)

**Указание пользовательского удалителя не влияет на размер объекта std::shared_ptr.**
Независимо от удалителя объект std::shared_ptr имеет размер, равный размеру двух указателей.

std::shared_ptr - имеет указатель на данные и на управляющий блок в котором находится информация о счетчеке указателей,
пользовательском удалителеб, опционально пользовательский распределитель памяти

![указатели shared_ptr](https://github.com/CapSmoIIett/cplusplus/blob/main/images/shared_ptr_1.png)

Управляющий блок объекта настраивается функцией, создающей первый указатель std::shared_ptr на объект.
при создании управляющего блока должны использоваться следующие правила:
- Функция std::make_shared всегда создает управляющий блок.
Она производит новый объект, на который будет указывать интеллектуальный
указатель, так что в момент вызова std::make_shared управляющий блок для этого объекта, определенно, не существует.
- Управляющий блок создается тогда, когда указатель std::shared_ptr создается из указателя с исключительным владением (т.е. std::unique_ptr или
std::auto_ptr). Указатели с исключительным владением не используют управляющие блоки, так что никакого управляющего блока для указываемого объекта не
существует. (Как часть своего построения std::shared_ptr осуществляет владение указываемым объектом, так что указатель с исключительным владением становится нулевым.) 
- Когда конструктор std::shared_ptr вызывается с обычным указателем, он создает управляющий блок.
(Если вы хотите создать std::shared_ptr из объекта, у которого уже имеется управляющий блок, вы предположительно передаете
в качестве аргумента конструктора std::shared_ptr или std::weak_ptr)

создание более одного std::shared_ptr из единственного обычного указателя  - ведет к неопределенному поведению

Старайтесь не передавать обычные указатели shared_ptr, если без этого не как, то передавайте сразу результа *new*, а не обычную переменную

С make_shared нельзя задать удалители

управляющий блок - размером в несколько слов (пользовательские удалители и распределители могут его увеличить)
(по  умолчанию при создании с помощью make_shared - около 3-х слов)

взаимодействие со счетчиком - 1/2 атомарные операции.

Обычно реализация управляющего блока применяет наследование и имеет виртуальные функции ( для коректного уничтожения) - 
это все то же увеичивает стоимость std::shared_ptr

**std::shared_ptr - не лучший способ управления ресурсами!**
*Но его стоимость/функицонал очень приятна*


**std::shared_ptr и this**

Создавть std::shared_ptr с помощью *this* - плохая идея.  
Но если нужно это сделать, используй std::еnаblе_shared_from_this.
std::еnаblе_shared_from_this - Это шаблон базового класса, который вы наследуете,
если хотите, чтобы класс, управляемый указателями std::shared_ptr, был способен
безопасно создавать std::shared_ptr из указателя this.

(std::enable_shared_from_this<T> - [CRTP](#crtp))
Шаблое std::enable_shared_from_this - определяет функцию член, которая создает std::shared_ptr для this (shared_from_this).
При этом он не дублирует управляющие блоки 

```C++
class Widget : public std::enable_shared_from_this<Widget>
{
public:
    void process( )
    {
        array.emplace_back(shared_from_this());
    }
};
```
std::shared_from_this - внутри ищет управляющий блок объекта и создает  std::share_ptr,
который использует этот же управляющий блок.
НО для этого управляющий блок должен быть создан.
Чтобы препятствовать вызову функции-члена, в которой используется
shared_from_this, до того как на объект будет указывать указатель std::shared_ptr,
классы, наследуемые от std::enable_shared_from_this, часто объявляют свои конструкторы как 
private и заставляют клиентов создавать объекты путем вызова фабричных функций, 
которые возвращают указатели std::shared_ptr.

```C++
class Widget : public std::enable_shared_from_this<Widget>
{
public:
    template<typename Ts>
    static std::shared_ptr<Widget> create(Ts&& ... params )  // Фабричная функция

private:
    // конструкторы

};
```
- std::shared_ptr предоставляет удобный подход к управлению временем жизни
произвольных ресурсов, аналогичный сборке мусора.
- По сравнению с std::unique_ptr объекты std::shared_ptr обычно в два раза
больше, привносят накладные расходы на работу с управляющими блоками и требуют атомарной работы со счетчиками ссылок.
• Освобождение ресурсов по умолчанию выполняется с помощью оператора delete,
однако поддерживаются и пользовательские удалители. Тип удалителя не влияет
на тип указателя std::shared_ptr.
• Избегайте создания указателей std::shared_ptr из переменных, тип которых -
обычный встроенный указатель. 

---

### std::weak_ptr

Проблема неизвестного указателя - ситуация когда умный указатель указывает на освобожденную память

std::weak_ptr - неявляется автономным интелектуальным указателем, это дополнение к std::shared_ptr. 
В нем нет операций разыменования 

std::weak_ptr создается из указателей std::shared_ptr, но не влияют на счетчики ссылок (У них есть совй), на который указывают

```c++
auto spw = std::make_shared<Widget>();

std::weak_ptr<Widget> wpw (spw) ;

spw = nullptr;
// после этого объект Widget уничтожается а wpw становиться висячим (просроченым - expired)

if (wpw.expired())  // проверка на то, просрочен ли указатель
```

чтобы из std::weak_ptr получить даные из него нужно сделать std::shared_ptr
Есть два пособа это сделать:
- std::weak_ptr::lock() - возвращает shared_ptr (нулевой если std::weak_ptr - expired)

```C++
std::shared_ptr<Widget> spw1 = wpw.lock();
auto spw2 = wpw.lock();
```

- конcтруктор std::shared_ptr

```c++
std::shared_ptr<Widget> spw(wpw);   // Если wpw просрочен генерирует std::bad_weak_ptr
```

Для чего нужен std::weak_ptr?
Пример: есть фабричный метод возвращающий умные указатели. 
Допустим этот метод очень нагружает систему.
Логично использование кэширования для улучшения производительности.
Но большое количество копий объекта очень засорит память.
Тогда кэшировать стоит, когда эти объекты больше нигде в программе не используются.
Тогда данный метод будет возвращать std::shared_ptr, а кэшировать std::weak_ptr.  
Грубая (очень грубая) реализация:
```c++
std::shared_ptr<const Widget> fastLoadWidget (Widget ID id)
{
    static std::unordered_map<WidgetID,
        std::weakytr<const Widget>> cache;
    
    auto obj_ptr = cache[id].lock(); 
    // obj Ptr является std::shared_pt для кешированного объекта и
    // нулевым указателем для объекта, отсутствующего в кеше

    if (!obj_ptr) 
    {
        obj_ptr = loadWidget (id);
        cache[id] = obj_ptr;
        //При отсутствии в кеше объект загружается и кешируется
    }

    return obj Ptr;
}
```

Второй пример применения:
Шаблон проектирования [Observer](#наблюдатель). 
В большинстве реализаций объект за которым наблюдают (субъект) имеет указатели на его наблюдателей.
Каждый субъект хранит контейнер std::weak_ptr на его наблюдателей.


Еще пример:
Есть структуры A, B,C. 
A и C имеют указатели на B.
![Пример weak_ptr](https://github.com/CapSmoIIett/cplusplus/blob/main/images/weak_ptr_1.png)
Нам нужен указатель из B на A, как это лучше делать?  
Варианты:
- **Обычный указатель**. 
В таком случае если A уничтожить, то B созранит висячий указатель на него.
- **std::shared_ptr**.
Если A и B имеют std::shared_ptr друг на друга то их уничтожение - большая проблема.
- **std::weak_ptr**. 
Этот вариант лишен выше указаных проблем.

std::weak_ptr - соразмерен std::shared_ptr (используют теже управляющие блоки).  
А создание, уничтожение, присваивание - атомарные операции взаимодействующие со счтечиком ссылок(они работают со своим счетчиком ссылок).

- Используйте std::weak_ptr как std::shared_ptr - oбpaзныe указатели, которые могут быть висячими.
- Потенциальные применения std::weak_ptr включают хеширование, списки наблюдателей и предупреждение циклов указателей std::shared_ptr. 

---

### std::make_unique и std::make_shared против new

### Row указатели (сырые или обычные)
    Недостатки перечисленные в 
[Эффективный и современныи С++: 42 рекомендации по использованию С++ 11 и С++ 14 - Скотт Мейерс](https://github.com/CapSmoIIett/cplusplus/blob/main/Books/%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%B8_%D1%81%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%A1_%D0%A1%D0%BA%D0%BE%D1%82%D1%82_%D0%9C%D0%B5%D0%B9%D0%B5%D1%80%D1%81.pdf) - стр 126:

1. Их объявление не дает информации о том, указывают ли они на один объект или на массив.
2. Их объявление ничего не говорит о том, должны ли вы уничтожить то, на что он
указывает, когда завершите работу, т.е. владеет ли указатель тем, на что указывает.
3. Если вы определили, что должны уничтожить то, на что указывает указатель, нет никакого способа указать, как это сделать. 
Должны ли вы использовать delete
или имеется иной механизм деструкции (например, специальная функция уничтожения, которой следует передать этот указатель)?
4. Если вам удалось выяснить, что требуется использовать оператор delete, то причина 1 означает, 
что нет никакого способа узнать, следует ли использовать оператор для удаления одного объекта (delete) или для удаления массива (delete []).
Если вы используете оператор неверного вида, результат будет неопределенным.
5. Если вы определили, что указатель владеет тем, на что указывает, и выяснили,
каким образом уничтожить то, на что он указывает, оказывается очень трудно
обеспечить уничтожение ровно один раз на каждом пути вашего кода (включая те,
которые возникают благодаря исключениям). Пропущенный путь ведет к утечке
ресурсов, а выполнение уничтожения более одного раза - к неопределенному поведению.
6. Обычно нет способа выяснить, не является ли указатель висячим, т.е. не указывает
ли он на память, которая больше не хранит объект, на который должен указывать
указатель. Висячие указатели образуются, когда объекты уничтожаются, в то время как указатели по-прежнему указывают на них.

## Организация кодовой базы
## Структуры и классы

Главное различие между классом и структурой в с++, по умолчанию область видимости полей в структуре - public, а у класса - private.

## Библиотеки и взаимодействие с ними
## Обработка ошибок

## Концепции языка

## Шаблоны

### CRTP
The Curiously Recurring Template Pattern - Странно повторяющийся шаблон

Пример этого: std::enable_shared_from_this<T>

## Идиомы

### RAII
*Resource Acquisition Is Initialization - Получение ресурса есть инициализация*

Идиома очень простая и кратко описывается следующим образом: в конструкторе объект получает доступ к какому либо ресурсу (например, открывается файл или устанавливается соединение по сети к базе данных) и сохраняет описатель ресурса в закрытый члена класса, а при вызове деструктура этот ресурс освобождается (закрывается файл или соединение к БД). При объявлении объекта данного класса на стеке происходит и его инициализация с вызовом конструктора, захватывающий ресурс. При выходе из области видимости объект выталкивается из стека, но перед этим вызывается деструктор объекта, который и освобождает захваченный ресурс.

[Источник](https://habr.com/ru/sandbox/21603/)

Основные моменты:

1. Обращение к ресурсу происходит в один этап. Либо мы получаем готовый полностью функциональный объект сразу, либо не получаем ничего.
2. Безопасность по отношению к исключению. Например, если после создания объекта и обращения к ресурсу произойдет исключение и мы перейдем к обработчику исключения, мы можем быть уверены что ресурс освободится без нашего участия. Даже если ресурсов несколько, мы уверены что все они будут корректно освобождены. В противном случае, если захватывать и освобождать ресурс вручную, то при возникновении исключения нужно учитывать, какие ресурсы уже захвачены, а какие – нет, и освобождать только использованные ресурсы, что не слишком просто.
3. Идиома очень удобна, когда нужно отслеживать важные ресурсы, а при этом сопровождение кода оставляет желать лучшего.
4. Часто при использовании нескольких ресурсов освобождать их следует в обратном порядке. При использовании идиомы RAII, вследствие того что объекты с захваченными ресурсами располагаются на стеке, их уничтожение происходит в обратном порядке, что как правило и является желательным.
5. Поддержка принципа DRY (Don’t Repeat Yourself). Код инициализации и освобождения ресурса содержится только в одном месте. Нет необходимости копировать и вставлять код инициализации в каждое место в программе где это необходимо. Достаточно просто создать объект.
6. При необходимости использовать дополнительные параметры для обращения к ресурсу (например, логин и пароль к БД) эти параметры могут быть переданы в качестве аргументов конструктора.
7. Накладные расходы при простейшей реализации обращения к ресурсу минимальны. В С++, как правило, при оптимизации компилятор реализует невиртуальные конструкторы и деструкторы в виде inline-функций.
8. Данная идиома применима только в языках с предсказуемым временем жизни объекта. Сюда относится, например, С++, а также языки с сборщиком мусора, где время жизни объекта определяется количеством ссылок на него, такие как Objective C.
9. Эта идиома неприменима в таких языках как Java или С#, где невозможно предсказать когда объект будет удален.

---

### pimpl

*pointer to implementation - указатель на реализацию*

Идиома **pimpl** - полезна в тех случаях, когда нам нужно что-то скрыть. Она обеспечивает еще более глубокий вид инкапсуляции, которая маскирует не просто реализацию, а также все ее зависимости.
Нужна для:
1. Для того, что бы была возможность изменять реализацию скрываемого класса без перекомпиляции остального кода, так как закрытые члены хоть и недоступны извне никому, кроме функций-членов и друзей, но видимы всем, кто имеет доступ к определению класса. Изменение определения класса приводит к необходимости перекомпиляции всех пользователей класса
2. Для сокрытия имен из области видимости. Закрытые члены хоть и не могут быть вызваны кодом вне класса, тем не менее они участвуют в поиске имен и разрешении перегрузок
3. Для ускорения времени сборки, так как компилятору не нужно обрабатывать лишние определения закрытых типов

Как мы этого добиваемся?
Переносим #include <название библтотеки> из .h в .cpp.
В .h дописываем необзодимый include

До:
```c++
// .h
#include "HideClass.h"

class A 
{
public:
    void fun();

private:
    HideClass b;
}


// .cpp
void A::fun()
{ /*Do something*/}
```

После:
```c++
// .h
class HideClass;

class A
{
public:
    A();
    ~A();
    void fun();

private:
    HideClass* b;
}


// .cpp
#include "HideClass.h"

A::A():
    b (new HideClass)
{ /*Do something*/}

A::~A()
{ delete b; }

void A::fun()
{ /*Do something*/}
```

В С++, в случае изменений в классе (даже в закрытых функциях членах) все пользователи данного класса должны быть перекомпилированы. 
Для избежания подобных зависимостей используется указатель на функции члены, реализацию которых необходимо скрыть.
Два основных недостатка заключаются в следующем:
1. Каждое создание объекта требует динамического выделения памяти для объекта, на который ссылается указатель
2. Использование нескольких уровней косвенности (как минимум — один) для доступа к членам скрытого объекта

Что же можно попробовать скрыть?

1. Только скрытые данные-члены
2. Все скрытые данные-члены и функции-члены. К сожалению, скрыть виртуальную функцию невозможно, так как она должна быть видима для производных классов. Также в закрытом классе может понадобиться ссылка на открытый класс для использования его функций
3. Закрытые и защищенные члены. К сожалению, защищенные члены скрыть нельзя, так как они должны быть доступны производным классам
4. Весь класс. Преимущество заключается в том, что закрытому классу не нужен указатель на открытый класс. С другой стороны, мы лишаемся возможностей наследования

(Сам до конца не понимаю указанное выше)

И еще: 
```c++
// .h
class HideClass;

class A
{
public:
    A();
    ~A();
    void fun();

private:
    int hideClassSize = 42;
    char hideClassObj[hideClassSize];
}


// .cpp
#include "HideClass.h"

A::A()
{
    assert(hideClassSize >= sizeof(HideClass));
    new(&hideClassObj[0]) HideClass;
}

A::~A()
{
    (reinterpret_cast<HideClass *> (&hideClassObj[0]))->~HideClass();
}

void A::fun()
{ /*Do something*/}
```

Кодом выше получилось избавиться отдинамического выделения памяти.

Нам удалось избавиться от объявления класса UnixSocketImpl в заголовочном файле GeneralSocket, и избавиться от динамического выделения памяти. Взамен мы получили ряд существенных недостатков:

1. С++ — язык со строгой типизацией, и данное ухищрение – попытка обойти ограничения языка
2. Проблемы с выравниванием памяти. Данный способ не гарантирует что память будет выравнена должным образом для всех членов UnixSocketImpl. Решение, которое не гарантирует полную переносимость, но все же работает в большинстве случаев – использование union:

### Non-Copyable/Non-Moveable

(Как я понял) Если есть класс который нельзя копировать и перемещать то просто удаляем его конструкторы копирования.

```c++
class NonCopyable
{
  public: 
    NonCopyable (const NonCopyable &) = delete;
    NonCopyable & operator = (const NonCopyable &) = delete;

  protected:
    NonCopyable () = default;
    ~NonCopyable () = default; /// Protected non-virtual destructor
};
class CantCopy : private NonCopyable
{};
```
[Источник](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-copyable_Mixin)
 
 ---

### Erase-Remove

Идиома **remove-erase idiom** призвана решить проблему удаления элементов из контейнера, поскольку данная проблема может представлять нетривиальную задачу, чреватую возникновением ошибок. 
Данная идиома предполагает применение алгоритма remove() или remove_if(), за которым следует вызов функции erase() контейнера.

При применении алгоритмов remove() и remove_if() те элементы, которые надо сохранить, помещаются в начало контейнера, а функции remove() и remove_if() возвращают итератор на первый удаляемый элемент. 
Затем этот итератор передается в функцию erase(), которая собственно и удаляет элементы.

[Источник](https://metanit.com/cpp/tutorial/16.4.php#:~:text=%D0%98%D0%B4%D0%B8%D0%BE%D0%BC%D0%B0%20remove%2Derase%20idiom%20%D0%BF%D1%80%D0%B8%D0%B7%D0%B2%D0%B0%D0%BD%D0%B0,%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%20erase()%20%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0.)

---

### Copy and swap

Когда нужно изменить состояние одного или нескольких объектов, и на любом этапе модификации может возникнуть ошибка, для создания кода, устойчиваого к ошибкам, может применяться **идиома копирования и замены (copy-and-swap idiom)**. 
Суть данной идиомы состоит в следующей последовательности действий:
1. Создаем копию объекта(ов)
2. Изменяем копию. При этом оригинальные объекты остаются нетронутыми
3. Если все изменения прошли успешно, заменяем оригинальный объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то оригинальный объект не заменяется.

[Источник](https://metanit.com/cpp/tutorial/13.1.php)

---

### Copy on write

Копирование объекта иногда может привести к снижению производительности. 
Если объекты часто копируются, но редко изменяются позже, копирование при записи может обеспечить значительную оптимизацию. 
Для реализации копирования при записи используется интеллектуальный указатель на реальное содержимое для инкапсуляции значения объекта, и при каждой модификации проверяется счетчик ссылок на объект; 
если на объект ссылаются более одного раза, перед модификацией создается копия содержимого.

Я понимаю это следующим образом:  
- много умных указателей на один элемент
- если хотим что-то поменять в данных по указателю для этого создаем его копию и работаем сней ( остальные умные указатели все еще указывают на оригинальный объект)

---

### CRTP

**Curiously Recurring Template Pattern (CRTP)** идиома языка C++, название которой можно примерно перевести как Странно рекурсивный шаблон или Странно повторяющийся шаблон, часто просто Рекурсивный Шаблон, состоящая в том, что некоторый класс X наследуется от шаблона класса, использующего X как шаблонный параметр.

[Классно работает с паттерном мост](https://habr.com/ru/articles/543098/)

---

## Стандарты

### C++98
### C++11
### C++14
### C++17
### c++20

# ООП

**Инкапсуляция** - механизм позволяющий связывать данные и методы работающие с этими данными в единый объект (использование this для обращения к полям класса)

**Наследование** - концепция согласно которой абстрактный тип данных может наследовать данные и функциональность некоторого существующего типа

**Полиморфизм** - способность функции обрабатывать данные разных типов.  
Перегрузки - вид полиморфизма (*Ad hoc* полиморфизм или специальный полиморфизм)
Инкапсуляция с наследованием нужны для реализации полиморфизмах, сами по себе они бесполезны и даже вредны

**Абстрактный класс** -  базовый класс, который не предполагает создания экземпляров (абстрактный класс объявляется включением хотя бы одной чистой виртуальной функции, типа virtual _сигнатура_функции_ =0;)

**Интерфейс** — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.

#### виртуальный конструктор
Виртуальный **конструктор** невозможен, так как на момент его вызова объекта ещё просто не существует - ещё даже не существует указателя.

Но если бы теоретически "виртуальный конструктор" существовал, то зачем он мог бы быть нужен? Самая простая причина - десериализация. Представим себе функцию/метод, которая на вход получает XML/JSON и каким-то магическим образом догадывается, какой объект был там сериализован, и возвращает объект нужного типа. Более того, в Java это используется... Просто называется по-другому. А называется это Фабричный метод.


#### Виртуальный деструктор
**Дeструктор** полиморфного базового класса должен объявляться виртуальным. Только так обеспечивается корректное разрушение объекта производного класса через указатель на соответствующий базовый класс.


[Источник](https://www.youtube.com/watch?v=BHNt1fcg8iw)

---

# Патерны

[Сайт с патернами](https://refactoring.guru/ru/design-patterns/catalo)

### Наблюдатель


## Порождающие

### Фабричный метод

## Структурные

### Адаптер
*Wrapper, Обёртка, AdapterI*

**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.  
Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.

Применение:  
- Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.

---

### Мост
*Bridge*

Пример:  
У вас есть класс геометрических Фигур, который имеет подклассы Круг и Квадрат. Вы хотите расширить иерархию фигур по цвету, то есть иметь Красные и Синие фигуры. Но чтобы всё это объединить, вам придётся создать 4 комбинации подклассов, вроде СиниеКруги и КрасныеКвадраты.  
Паттерн Мост предлагает заменить наследование агрегацией или композицией. Для этого нужно выделить одну из таких «плоскостей» в отдельную иерархию и ссылаться на объект этой иерархии, вместо хранения его состояния и поведения внутри одного класса.

**Мост** — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

---

## Структурные 

## Поведеньческие

---

# Алгоритмы и структуры данных

# STL

## Контейнеры

*или коллекции*

![алгоритм выбора контейнера](https://github.com/CapSmoIIett/cplusplus/blob/main/images/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B.png)

![скорости работы контейнеров](https://github.com/CapSmoIIett/cplusplus/blob/main/images/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%B3%D0%B5%D1%80%D1%8B_%D1%81%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D1%8C%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B.jpg)

### Контейнеры последовательности:

### Array

Контейнер array  представляет аналог массива. Имеет фиксированный размер.
Для создания объекта array в угловых скобках после названия типа необходимо передать его тип и размер:

```c++
std::array<int, 5> numbers; 
```

В array-е все объекты инициальизируются сразу. 
По правилам C++ в массиве инициализация объектов происходит слева направо, уничтожение справа налево.

Если у объекта array тривиальный конструктор/деструктор (совсем ничего не делает), то кроме выделения памяти ничего не происходит.

![устройство array](https://github.com/CapSmoIIett/cplusplus/blob/main/images/array_1.png)

### Vector

vector — коллекция элементов, сохраненных в массиве, изменяющегося по мере необходимости размера (обычно, увеличивающегося);

vector - реализует динамический массив. 
Размер вектора — это фактическое число элементов, а объём — количество используемой им памяти. 
Если при вставке в вектор новых элементов, его размер становится больше его объёма, происходит перераспределение памяти. Как правило, это приводит к тому, что вектор выделяет новую область хранения, перемещая элементы и свободные старые области в новый участок памяти. 
Поскольку адреса элементов в течение этого процесса меняются, любые ссылки или итераторы элементов в векторе могут стать недействительными. Использование недействительных ссылок приводит к неопределённому поведению.

устройство вектора:

Выделаяет память в куче. 
Хранит указатели на начало данных, конец данных и следующую ячейку памяти после выделенной под вектор.
Объект в заранее аллоцированной памяти создается с помощью конструкции [placement new](https://www.geeksforgeeks.org/placement-new-operator-cpp/). 
А начиная с C++11 с вводом perfect [forwarding](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F_%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0_(C%2B%2B)) новый объект для вектора можно создавать in-place (с помощью метода emplace/emplace_back)

.size() - количество объяектов в векторе.  
.capacity() - под какое количество объектов зарезервированна память.

![устройство вектора](https://github.com/CapSmoIIett/cplusplus/blob/main/images/vector_1.png)

вставка нового элемента:

![вставка нового элемента](https://github.com/CapSmoIIett/cplusplus/blob/main/images/vector_2.png)

вставка нового элемента, в случае когда размер становится больше объема:

при нехватке места ветор увеличивается в 2 раза.

![вставка нового элемента, в случае когда размер становится больше объема](https://github.com/CapSmoIIett/cplusplus/blob/main/images/vector_3.png)

### Deque

Это контейнер с быстрым добавлением объектов в начало и в конец.
Вся память разбивается на несколько кусков памяти (чанков) одинаковой величины.

![устройство deque](https://github.com/CapSmoIIett/cplusplus/blob/main/images/deque_1.png)

Указатели на чанки находятся в контейнере, похожем на вектор (с мелкими отличиями).
Получение ссылки на объект проводится через 2 разыменования (вместо 1 у std::vector).

Если нельзя добавить объект в начало/конец, то сначала аллоцируется новый чанк памяти. 
В худшем случае аллокаций будет два, потому что может понадобиться реаллокация контейнера указателей на чанки.

Плюс контейнера в том, что при добавлении новых объектов в начало/конец никакие существующие ссылки/указатели на другие объекты контейнера не инвалидируются.

### forward_list

Это однонаправленный список - самая простая реализация списка. Список состоит из вершин.
Вершина списка это сам объект и указатель на следующую вершину (указатель принимает значение nullptr, если объект последний в списке).

Контейнер поддерживает быструю вставку и удаление объектов в любом месте, потому что для этого понадобится только правка next_ptr у вершины слева.
Впрочем, "быстрая вставка" относится исключительно к алгоритмической сложности.
Aллокация памяти для новой вершины может быть небыстрой.

Быстро получить N-й объект нельзя, для этого нужно пройтись от корневой вершины по next_ptr N раз.
Размер списка тоже можно узнать только пройдя по всем next_ptr, пока не увидим nullptr.
У контейнера даже нет метода .size().

![устройство forward_list](https://github.com/CapSmoIIett/cplusplus/blob/main/images/forward_list_1.png)

### List

Это более сложная организация списка.
Она имеет все те же свойства, как у std::forward_list, но вершины дополнительно могут ссылаться на предыдущие вершины, и есть быстрое добавление в конец списка.

![устройство list](https://github.com/CapSmoIIett/cplusplus/blob/main/images/list_1.png)

.size() - есть

### Контейнеры-адаптеры

Некоторые контейнеры не имеют хитрого внутреннего устройства, и их функционал базируется на функционале какого-нибудь другого контейнера.

В них используется инкапсулированный объект контейнера в качестве базового контейнера, представляя определенный набор функций членов для доступа к его элементам. 

Базовым контейнером может быть любой из стандартных шаблонов класса контейнера или какой-либо другой специально разработанный класс контейнера. 

В STL таких контейнеров три: (stack, queue, priority_queue)

### Stack

Класс std::stack<T> представляет стек - контейнер, который работает по принципу LIFO (last-in first-out или "последний вошел — первым вышел") — первым всегда извлекается последний добавленный элемент.
Стек можно сравнить со стопкой предметов, например, стопкой тарелок - тарелки добавляются сверху, каждая последующая тарелка кладется поверх предыдущей.
А если надо взять тарелку, то сначала берется та, которая в самом верху (которую положили самой последней).

базовый контейнер по умолчанию (deque).

В базовом контейнеры должны быть реализованны:
- empty
- size
- back
- push_back
- pop_back

[источник](https://cplusplus.com/reference/stack/stack/)

### Queue

Адаптивынй контейнер для работы по принципу FIFO (первым пришел — первым вышел), где элементы вставляются в один конец контейнера и извлекаются из другого.

базовый контейнер по умолчанию (deque).

Базовый контейнер должен поддерживать как минимум следующие операции:
- empty
- size
- front
- back
- push_back
- pop_front

### priority_queue

priority_queue представляет очередь приоритетов - контейнер, который, как и станлдартная очередь, работает по принципу FIFO.
При добавлении элементов в очередь приоритетов применяется функция компаратора, которая сравнивает добавляемые элементы и располагает их в очереди в определенном порядке.

Вставиви в pq следующие значения: { 2, 10, 4, 8, 6, 9 };
получим: {10, 9, 8, 6, 4, 2}

### ассоциативные контейнеры

### Set

Контейнер, в котором хранятся уникальные элементы в определенном порядке.

В set значение элемента также является его идентификатором (значение является ключом типа T), и каждое значение должно быть уникальным. 
Значение элементов в set нельзя изменить после добавления в контейнер (элементы всегда const), но их можно вставлять или удалять из контейнера.

Внутренне элементы в set всегда отсортированы в соответствии с определенным строгим критерием слабого упорядочивания, указанным его внутренним объектом сравнения (типа Compare).

Контейнеры set обычно медленнее контейнеров unordered_set при доступе к отдельным элементам по их ключу, но они позволяют прямую итерацию по подмножествам в соответствии с их порядком.

set обычно реализованы в виде бинарных деревьев поиска.


Свойства контейнеров:

- Ассоциативные.
Элементы в ассоциативных контейнерах идентифицируются по ключу, а не по их абсолютной позиции в контейнере.

- Упорядоченные. 
Элементы в контейнере всегда следуют строгому порядку. Все вставленные элементы занимают определенную позицию в этом порядке.

- Множество (Set). 
Значение элемента также является ключом, используемым для его идентификации.

- Уникальные ключи. 
Ни одни два элемента в контейнере не могут иметь эквивалентные ключи.

- Allocator-aware.
Контейнер использует объект аллокатора для динамической обработки своих потребностей в памяти.

### Multiset

Мультимножества (Multiple-key set) - это контейнеры, которые хранят элементы в определенном порядке, где несколько элементов могут иметь эквивалентные значения.

В мультимножестве значение элемента также является его идентификатором (значение является ключом типа T). Значение элементов в мультимножестве нельзя изменить после добавления в контейнер (элементы всегда const), но их можно вставлять или удалять из контейнера.

Внутренне элементы в мультимножестве всегда отсортированы в соответствии с определенным строгим критерием слабого упорядочивания, указанным его внутренним объектом сравнения (типа Compare).

Контейнеры мультимножества обычно медленнее контейнеров unordered_multiset при доступе к отдельным элементам по их ключу, но они позволяют прямую итерацию по подмножествам в соответствии с их порядком.

Мультимножества обычно реализованы в виде бинарных деревьев поиска.

Свойства контейнеров:

- Ассоциативные.
Элементы в ассоциативных контейнерах идентифицируются по своему ключу, а не по абсолютной позиции в контейнере.

- Упорядоченные. 
Элементы в контейнере всегда следуют строгому порядку. Все вставленные элементы занимают определенную позицию в этом порядке.

- Множество (Set).
Значение элемента также является ключом, используемым для его идентификации.

- Множество с множественными эквивалентными ключами. 
В контейнере может быть несколько элементов с эквивалентными ключами.

- Allocator-aware.
Контейнер использует объект аллокатора для динамической обработки своих потребностей в памяти.

### Map

Карты (Map) - это ассоциативные контейнеры, которые хранят элементы, состоящие из комбинации значения ключа и значения отображаемого элемента, следуя определенному порядку.

В map ключи обычно используются для сортировки и уникальной идентификации элементов, а значения отображают содержимое, связанное с этим ключом. Типы ключа и отображаемого значения могут отличаться и объединены в типе-члене value_type, который является типом пары, объединяющей оба значения:

```cpp
typedef pair<const Key, T> value_type;
```
Внутренне элементы в map всегда отсортированы по ключу в соответствии с определенным строгим критерием слабого упорядочивания, указанным его внутренним объектом сравнения (типа Compare).

Контейнеры map обычно медленнее контейнеров unordered_map при доступе к отдельным элементам по их ключу, но они позволяют прямую итерацию по подмножествам в соответствии с их порядком.

Значения отображаемых элементов в map могут быть получены напрямую по соответствующему ключу с использованием оператора квадратных скобок (operator[]).

map обычно реализованы в виде бинарных деревьев поиска.

Свойства контейнеров:

- Ассоциативные.
Элементы в ассоциативных контейнерах идентифицируются по ключу, а не по их абсолютной позиции в контейнере.

- Упорядоченные.
Элементы в контейнере всегда следуют строгому порядку. Все вставленные элементы занимают определенную позицию в этом порядке.

- Карта (Map).
Каждый элемент ассоциирует ключ с отображаемым значением: ключи предназначены для идентификации элементов, основное содержимое которых является отображаемым значением.

- Уникальные ключи. 
Ни одни два элемента в контейнере не могут иметь эквивалентные ключи.

- Allocator-aware. 
Контейнер использует объект аллокатора для динамической обработки своих потребностей в памяти.

### Multimap

Мультимапы (Multiple-key map) - это ассоциативные контейнеры, которые хранят элементы, состоящие из комбинации значения ключа и значения отображаемого элемента, следуя определенному порядку, где несколько элементов могут иметь эквивалентные ключи.

В multimap ключи обычно используются для сортировки и уникальной идентификации элементов, а значения отображают содержимое, связанное с этим ключом. Типы ключа и отображаемого значения могут отличаться и объединены в типе-члене value_type, который является типом пары, объединяющей оба значения:

Внутренне элементы в multimap всегда отсортированы по ключу в соответствии с определенным строгим критерием слабого упорядочивания, указанным его внутренним объектом сравнения (типа Compare).

Контейнеры multimap обычно медленнее контейнеров unordered_multimap при доступе к отдельным элементам по их ключу, но они позволяют прямую итерацию по подмножествам в соответствии с их порядком.

multimap обычно реализованы в виде бинарных деревьев поиска.

Свойства контейнеров:

- Ассоциативные.
Элементы в ассоциативных контейнерах идентифицируются по своему ключу, а не по абсолютной позиции в контейнере.

- Упорядоченные.
Элементы в контейнере всегда следуют строгому порядку. Все вставленные элементы занимают определенную позицию в этом порядке.

- Карта (Map).
Каждый элемент ассоциирует ключ с отображаемым значением: ключи предназначены для идентификации элементов, основное содержимое которых является отображаемым значением.

- Множество эквивалентных ключей.
В контейнере может быть несколько элементов с эквивалентными ключами.

- Allocator-aware. 
Контейнер использует объект аллокатора для динамической обработки своих потребностей в памяти.

### Unordered set

Unordered Set (Неупорядоченное множество) - это контейнер, который хранит уникальные элементы в произвольном порядке и позволяет быстро получать отдельные элементы на основе их значения.

В unordered_set значение элемента одновременно является его ключом, который уникально идентифицирует его. Ключи неизменяемы, поэтому элементы в неупорядоченном множестве не могут быть изменены после размещения в контейнере. Однако, элементы могут быть вставлены и удалены из множества.

Внутренне элементы в unordered_set не отсортированы по какому-либо определенному порядку, но они организованы в корзины (buckets) в зависимости от их хэш-значений, что позволяет быстро получать отдельные элементы напрямую по их значениям (с постоянной средней сложностью по времени).

unordered_set обычно работают быстрее, чем упорядоченные множества, при доступе к отдельным элементам по их ключу, хотя они в целом менее эффективны для итерации по подмножеству элементов.

### Unordered_multiset


Unordered Multiset (Неупорядоченный мультимножество) - это контейнер, который хранит элементы в произвольном порядке, позволяя быстро получать отдельные элементы на основе их значения, подобно неупорядоченному множеству (unordered_set), но позволяющий различным элементам иметь эквивалентные значения.

В unordered_multiset значение элемента одновременно является его ключом, используемым для его идентификации. Ключи неизменяемы, поэтому элементы в unordered_multiset не могут быть изменены после размещения в контейнере. Однако, элементы могут быть вставлены и удалены из мультимножества.

Внутренне элементы в unordered_multiset не отсортированы по какому-либо определенному порядку, но они организованы в корзины (buckets) в зависимости от их хэш-значений, что позволяет быстро получать отдельные элементы напрямую по их значениям (с постоянной средней сложностью по времени).

Элементы с эквивалентными значениями группируются в одну корзину и таким образом, что итератор (см. equal_range) может перебирать их все.

Итераторы в контейнере являются по крайней мере прямыми итераторами (forward iterators).

Обратите внимание, что этот контейнер не определен в своем собственном заголовочном файле, но использует заголовочный файл <unordered_set> вместе с неупорядоченным множеством (unordered_set).

### Unordered map


Unordered Map  - это ассоциативный контейнер, который хранит элементы, состоящие из комбинации ключевого значения и отображаемого значения, и позволяет быстро получать отдельные элементы на основе их ключей.

В unordered_map ключевое значение обычно используется для уникальной идентификации элемента, в то время как отображаемое значение является объектом, содержащим связанное с этим ключом содержимое. Типы ключа и отображаемого значения могут отличаться.

Внутренне элементы в unordered_map не отсортированы по какому-либо определенному порядку ни по ключу, ни по отображаемым значениям, но они организованы в корзины (buckets) в зависимости от их хэш-значений, что позволяет быстро получать отдельные элементы напрямую по их ключевым значениям (с постоянной средней сложностью по времени).

unordered_map работают быстрее, чем map, при доступе к отдельным элементам по их ключу, хотя они в целом менее эффективны для итерации по подмножеству элементов.

unordered_map реализуют оператор прямого доступа (operator[]), который позволяет прямой доступ к отображаемому значению с использованием его ключевого значения в качестве аргумента.

Итераторы в контейнере являются по крайней мере прямыми итераторами (forward iterators).

### Unordered multimap


Unordered Multimap - это ассоциативный контейнер, который хранит элементы, состоящие из комбинации ключевого значения и отображаемого значения, подобно неупорядоченному отображению (unordered_map), но позволяющий различным элементам иметь эквивалентные ключи.

В unordered_multimap ключевое значение обычно используется для уникальной идентификации элемента, в то время как отображаемое значение является объектом, содержащим связанное с этим ключом содержимое. Типы ключа и отображаемого значения могут отличаться.

Внутренне элементы в unordered_multimap не отсортированы по какому-либо определенному порядку ни по ключу, ни по отображаемым значениям, но они организованы в корзины (buckets) в зависимости от их хэш-значений, что позволяет быстро получать отдельные элементы напрямую по их ключевым значениям (с постоянной средней сложностью по времени).

Элементы с эквивалентными ключами группируются в одну корзину и таким образом, что итератор (см. equal_range) может перебирать их все.

Итераторы в контейнере являются по крайней мере прямыми итераторами (forward iterators).

Обратите внимание, что этот контейнер не определен в своем собственном заголовочном файле, но использует заголовочный файл <unordered_map> вместе с неупорядоченным отображением (unordered_map).

### Битовые контейнеры

Битовые контейнеры нужны для управления последовательностью из N битов.
Cпециальный контейнер для битов в 8 раз эффективнее по памяти.

В std::bitset<N>, который лежит на стеке, количество битов нужно знать "заранее".
Изначально все биты заполняются нулями. 
В контейнере есть несколько разнообразных методов для управления битами (всеми битами или конкретным битом)

Групповые операции, например .count() работают намного быстрее, чем если бы они совершались в обычном цикле for.
Процессоры умеют производить все битовые операции над числом в одну инструкцию.

operator[] (size_t pos) переопределен так, чтобы на его вызов возвращался "легкий" объект
std::bitset::reference, в котором находится указатель на число и "маска" бита.
И в свою очередь у этого объекта переопределен operator=(bool x), который производит запись в нужный бит.

если использовать vector<bool> вместо bitset:
- нельзя использовать укащатели на объект
- отсутствуют элементарные групповые операции над битами

---

## Строки

В STL строки представляются как в формате ASCII, так и Unicode:  
**string** — коллекция однобайтных символов в формате ASCII;  
**wstring** — коллекция двухбайтных символов в формате Unicode;  

## Строковые потоки

strstream — используются для организации STL-строкового сохранения простых типов данных.

Следующий пример берет строку из общего потока ввода и разбивает его на слова (для обработки введенных команд):
```c++
std::getline(std::cin, msg);        // Берем строку из стандартного ввода
std::istringstream iSStream(msg);   // Строкой иницируем поток

std::transform(msg.begin(), msg.end(), msg.begin(),
    [](unsigned char c) { return std::tolower(c); });   // Все символы в нижний регистр

std::string word;
while (iSStream >> word)            // Цикл по словам потока
    commands.push_back(word);       // Сохраняем сллова в вектор команд
```

## Итераторы

Итераторы обеспечивают доступ к элементам контейнера и представляют реализацию распространенного паттерна объектно-ориентированного программирования "Iterator".
С помощью итераторов очень удобно перебирать элементы.
В C++ итераторы реализуют общий интерфейс для различных типов контейнеров, что позволяет использовать единой подход для обращения к элементам разных типов контейнеров.

Стоит отметить, что итераторы имеют только контейнеры, адаптеры контейнеров — типы std::stack, std::queue и std::priority_queue итераторов не имеют.

Существуют три типа итераторов:  
1. (forward) iterator — для обхода коллекции от меньшего индекса к большему;  
2. reverse iterator — для обхода коллекции от большего индекс к меньшему;  
3. random access iterator — для обхода коллекции в любом направлении.  

Важно понимать, что при получении итератора на какой-то элемент коллекции и последующем изменении коллекции итератор может стать непригоден для использования.

## Алгоритмы

Методы перебора всех элементов коллекции и их обработки:  
[count](https://cplusplus.com/reference/algorithm/count/) - Возвращает количество элементов в диапазоне [first,last), которые равны val ;  
[count_if](https://cplusplus.com/reference/algorithm/count_if/)- Возвращает количество элементов в диапазоне, [first,last)для которых значение *pred* истинно.;  
[find](https://cplusplus.com/reference/algorithm/find/) - Возвращает итератор к первому элементу в диапазоне [first,last), который сравнивается с равным *val* . Если такой элемент не найден, функция возвращает *last* .;  
[find_if](https://cplusplus.com/reference/algorithm/find/) - Возвращает итератор к первому элементу в диапазоне, [first,last)для которого *pred* возвращает *true*. Если такой элемент не найден, функция возвращает *last*.;  
adjacent_find;  
for_each;  
mismatch;  
equal;  
search copy;  
copy_backward;  
swap;  
iter_swap;  
swap_ranges;  
fill;  
fill_n;  
generate;  
generate_n;  
replace;  
replace_if;  
transform;  
remove;  
remove_if;  
remove_copy;  
remove_copy_if;  
unique;  
unique_copy;  
reverse;  
reverse_copy;  
rotate;  
rotate_copy;  
random_shuffle;  
partition;  
stable_partition;  

Методы сортировки коллекции:  
[sort](https://cplusplus.com/reference/algorithm/sort/) - Сортирует элементы диапазона [first,last)в порядке возрастания. Элементы сравниваются с использованием operator<для первой версии и комп для второй.;  
stable_sort;  
partial_sort;  
partial_sort_copy;  
nth_element;  
binary_search;  
lower_bound;  
upper_bound;  
equal_range;  
merge;  
inplace_merge;  
includes;  
set_union;  
set_intersection;  
set_difference;  
set_symmetric_difference;  
make_heap;  
push_heap;  
pop_heap;  
sort_heap;  
min;  
max;  
min_element;  
max_element;  
lexographical_compare;  
next_permutation;  
prev_permutation;  

Методы выполнения определенных арифметических операций над членами коллекций:  
[Accumulate](https://cplusplus.com/reference/numeric/accumulate/) - Возвращает результат накопления всех значений в диапазоне [first,last) для *init* .;  
inner_product;  
partial_sum;  
adjacent_difference;  

### Предикаты
Для многих алгоритмов STL можно задать условие, посредством которого алгоритм определит, что ему делать с тем или иным членом коллекции.
Предикат — это функция, которая принимает несколько параметров и возвращает логическое значение (истина/ложь). 
Существует и набор стандартных предикатов.

## Потокобезопасность
Важно понимать, что STL — не потокобезопасная библиотека. Но решить эту проблему очень просто: если два потока используют одну коллекцию, просто реализуйте критическую секцию и Mutex.

---

# Системы сборки

[Введение в Системы Сборки для C++](https://www.youtube.com/watch?v=CCBH8UQHCW4)  
[В чем набрать и чем собрать C++ проект](https://habr.com/ru/articles/442682/)

## Make

**make** — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. 
Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта.  
Cам скрипт состоит из набора правил, которые в свою очередь описываются:
1. целями (то, что данное правило делает);
2. реквизитами (то, что необходимо для выполнения правила и получения целей);
3. командами (выполняющими данные преобразования).

В общем виде синтаксис makefile можно представить так:

```make
# Индентация осуществляется исключительно при помощи символов табуляции,
# каждой команде должен предшествовать отступ
<цели>: <реквизиты>
	<команда #1>
	...
	<команда #n>

```

Пример:

```make
all:
	clear
	gcc -shared -fpic -g mylib.c -o mylib.so -lrt
	gcc -g -o main main.c -ldl #mylib.so 
	./main

c:
	clear
	gcc -g mylib.c -o mylibtest
	./mylibtest	
```

### Инкрементная компиляция

```make
main.o: main.c
        gcc -c -o main.o main.c
hello.o: hello.c
        gcc -c -o hello.o hello.c
hello: main.o hello.o
        gcc -o hello main.o hello.o
```

### Фиктивные цели

На самом деле, в качестве make целей могут выступать не только реальные файлы. 
Все, кому приходилось собирать программы из исходных кодов должны быть знакомы с двумя стандартными в мире UNIX командами:

```bash
	$ make
	$ make install
```

Командой make производят компиляцию программы, командой make install — установку. 
Такой подход весьма удобен, поскольку все необходимое для сборки и развертывания приложения в целевой системе включено в один файл (забудем на время о скрипте configure). 
Обратите внимание на то, что в первом случае мы не указываем цель, а во втором целью является вовсе не создание файла install, а процесс установки приложения в систему. 
Проделывать такие фокусы нам позволяют так называемые фиктивные (phony) цели. 
Вот краткий список стандартных целей:

- all — является стандартной целью по умолчанию. При вызове make ее можно явно не указывать.
- clean — очистить каталог от всех файлов полученных в результате компиляции.
- install — произвести инсталляцию
- uninstall — и деинсталляцию соответственно.

Для того чтобы make не искал файлы с такими именами, их следует определить в Makefile, при помощи директивы .PHONY. 
Далее показан пример Makefile с целями all, clean, install и uninstall:

```make
.PHONY: all clean install uninstall
	
all: hello
	
clean:
			rm -rf hello *.o
main.o: main.c
			gcc -c -o main.o main.c
hello.o: hello.c
			gcc -c -o hello.o hello.c
hello: main.o hello.o
			gcc -o hello main.o hello.o
install:
			install ./hello /usr/local/bin
uninstall:
			rm -rf /usr/local/bin/hello
```

## Переменные 

Переменные в make представляют собой именованные строки и определяются очень просто:

```make
<VAR_NAME> = <value string>

SRC = main.c hello.c

gcc -o hello $(SRC)
```

# Автоматические переменные

Автоматические переменные предназначены для упрощения мейкфайлов, но на мой взгляд негативно сказываются на их читабельности. 
Как бы то ни было, я приведу здесь несколько наиболее часто используемых переменных, а что с ними делать (и делать ли вообще) решать вам:

```make
$@ Имя цели обрабатываемого правила
$< Имя первой зависимости обрабатываемого правила
$^ Список всех зависимостей обрабатываемого правила
```

[Просто о make](https://habr.com/ru/articles/211751/)  

---

## CMake

CMake — это расширяемая система с открытым исходным кодом, которая управляет процессом сборки в операционной системе и независимо от компилятора.
В отличие от многих кроссплатформенных систем, CMake предназначен для использования в сочетании с собственной средой сборки. 
Простые файлы конфигурации, размещенные в каждом исходном каталоге (называемые файлами CMakeLists.txt), используются для создания стандартных файлов сборки (например, make-файлов в Unix и проектов/рабочих областей в Windows MSVC), которые используются обычным образом. 
CMake может создать собственную среду сборки, которая будет компилировать исходный код, создавать библиотеки, генерировать оболочки и создавать исполняемые файлы в произвольных комбинациях. 
CMake поддерживает сборки на месте и вне места и, следовательно, может поддерживать несколько сборок из одного исходного дерева. CMake также поддерживает статические и динамические сборки библиотек. 
Еще одна приятная особенность CMake заключается в том, что он создает файл кеша, предназначенный для использования с графическим редактором. 
Например, при запуске CMake находит файлы, библиотеки и исполняемые файлы и может столкнуться с необязательными директивами сборки. 
Эта информация собирается в кэш, который может быть изменен пользователем до создания собственных файлов сборки.

CMake — кроcсплатформенная утилита для автоматической сборки программы из исходного кода. 
При этом сама CMake непосредственно сборкой не занимается, а представляет из себя front-end. 
В качестве back-end-a могут выступать различные версии make и Ninja. 
Так же CMake позволяет создавать проекты для CodeBlocks, Eclipse, KDevelop3, MS VC++ и Xcode.
Стоит отметить, что большинство проектов создаются не нативных, а всё с теми же back-end`ами

```cmake
cmake_minimum_required(VERSION 2.8) # Проверка версии CMake.
									# Если версия установленой программы
									# старее указаной, произайдёт аварийный выход.

add_executable(main main.cpp)		# Создает исполняемый файл с именем main
									# из исходника main.cpp
```

Синтаксис CMake похож на синтаксис bash.
Всё что после символа "#" является комментарием и обрабатываться программой не будет. 
CMake позволяет не засорять дерево исходных кодов временными файлами — очень просто и без лишних телодвижений сборка производится «Out-of-Source».

```bash
cmake /Путь_К_Исходникам/
```

### Библиотеки

```cmake
project(hello_world)			# Название проекта

set(SOURCE_EXE main.cpp)		# Установка переменной со списком исходников для исполняемого файла

set(SOURCE_LIB foo.cpp)			# Тоже самое, но для библиотеки

add_library(foo STATIC ${SOURCE_LIB})	# Создание статической библиотеки с именем foo

add_executable(main ${SOURCE_EXE})	# Создает исполняемый файл с именем main

target_link_libraries(main foo)		# Линковка программы с библиотекой
```

Переменные могут хранить списки значений, разделённых пробелами\табуляциями\переносами:
```cmake
set(SOURCE main.cpp foo.cpp)
set(HEADER main.h
			foo.h)
```

Что бы получить значение переменной ипользуем конструкцию:
```cmake
${var_name}
```

### Подпроекты

Каждый подпроект является по сути полноценным проектом и может использоваться самостоятельно.

Команда указывает компилятору, где искать заголовочные файлы. 
Может быть вызвана несколько раз. 
Хэдеры будут искаться во всех указаных директориях.
```cmake
include_directories(foo)			# Расположение заголовочных файлов
```

Указать директорию с подпроектом:
```cmake
add_subdirectory(foo)
```

### Поиск библиотек

CMake обладает достаточно развитыми средствами поиска установленых библиотек, правда они не встроеные, а реализованы в виде отдельных модулей. 
В стандартной поставке довольно много модулей, но некоторые проекты (например Ogre) поставляют свои. 
Они позволяют системе автоматически определить наличие необходимых для линковки проекта библиотек.

Поиск библиотеки. 
Если в системе её нет, выведется сообщение об ошибке и завершается выполнение cmake.
```cmake
find_package(SDL REQUIRED)
if(NOT SDL_FOUND)
	message(SEND_ERROR "Failed to find SDL")
	return()
else()
	include_directories(${SDL_INCLUDE_DIR})
endif()
```

Поиск необходимого компонента
```cmake
find_package(Boost COMPONENTS thread-mt REQUIRED)
if(NOT Boost_FOUND)
	message(SEND_ERROR "Failed to find boost::thread-mt.")
	return()
else()
	include_directories(${Boost_INCLUDE_DIRS})
endif()
```
SDL_FOUND, Boost_FOUND — признак присутствия бибилиотеки;  
SDL_LIBRARY, Boost_LIBRARIES — имена библиотек для линковки;  
SDL_INCLUDE_DIR, Boost_INCLUDE_DIRS — пути к заголовочным файлам.  

### Внешние библиотеки и объектные файлы:

Если вы пишите для «дяди», а злой «дядя» любит самописные библиотеки и делиться исходниками не желает, поэтому присылает готовую библиотеку, то вы по адресу.  
Объектные файлы в CMake стоят на ряду с исходниками — достаточно включить объектник в список файлов для компиляции.

```cmake
add_library(netutil STATIC IMPORTED)
set_property(TARGET netutil PROPERTY
             IMPORTED_LOCATION Binary/game_client/libnetutil.a)
```
Слово «IMPORTED», указывает, что библиотека берётся извне.  
В CMake каждая цель имеет параметры, а set_property позволяет их изменять.
Линкуется такая библиотека стандартно:

```cmake
target_link_libraries(${TARGET} netutil)
```
Для динамических библиотек все аналогично, только тип «SHARED», расширение — ".so".

### Генераторы

Как было сказано в начале, CMake умеет генерировать множество различных видов проектов. 
Это удобно и позволяет использовать CMake для практически любой популярной IDE.
Если запустить cmake без параметров, в конце будут описаны доступные генераторы.

```bash
$ cmake ~/cmake/example_3/ -G "KDevelop3 — Unix Makefiles"
```

[Введение в CMake](https://habr.com/ru/articles/155467/)

---

## Ninja

## Bazel

## Premake  


# Пакетные менеджеры

# Контроль версий (Git)

```bash
# Установим пользователя
# Кавычки оставляем
git config --global user.name "<ваше_имя>"

# Теперь установим email. 
git config --global user.email "<адрес_почты@email.com>"

# Инициализация/создание репозитория
git init

# Добавим все файлы проекта в нам будующий commit
git add *
git add .
git add --all

# Если хотим добавить конкретный файл то можно так
git add <имя_файла> 

# Создание коммита
# И не забываем про кавычки
git commit -m "<комментарий>"

git clone https://github.com/CapSmoIIett/cplusplus.git
# клонирует репозиторий в новый каталог

git status
# показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, 
# но не добавлены в индекс; какие ожидают коммита в индексе.

git diff
# используется для вычисления разницы между любыми двумя Git деревьями. 
# Это может быть разница между вашей рабочей копией и индексом (собственно 
# git diff), разница между индексом и последним коммитом (git diff --staged), 
# или между любыми двумя коммитами (git diff master branchB).

git reset 
# используется в основном для отмены изменений. 
# Она изменяет указатель HEAD и, опционально, состояние индекса

git branch
# это своего рода "менеджер веток". Она умеет перечислять 
# ваши ветки, создавать новые, удалять и переименовывать их.

git checkout
# Команда git checkout используется для переключения веток 
# и выгрузки их содержимого в рабочий каталог.
```

```bash
git merge
# Команда git merge используется для слияния одной или 
# нескольких веток в текущую. Затем она устанавливает указатель 
# текущей ветки на результирующий комми
```

![merge,rebase,squash](https://github.com/CapSmoIIett/cplusplus/blob/main/images/git_1.png)

git squash - сжатие комитов для rebase (не знаю почему на фото с squash merge) 


```bash
git log
# используется для просмотра истории коммитов, начиная с 
# самого свежего и уходя к истокам проекта.

git stash
git stash pop
git stash show
git stash drop
# используется для временного сохранения всех незафиксированных 
# изменений с целью очистки рабочего каталога без необходимости 
# фиксировать незавершённую работу в текущей ветке.

git tag 
# используется для задания постоянной метки на какой-либо 
# момент в истории проекта. Обычно она используется для релизов.

git fetch
# связывается с удалённым репозиторием и забирает из него 
# все изменения, которых у вас пока нет и сохраняет их локально.

git pull
# работает как комбинация команд git fetch и git merge, т. е. G
# it вначале забирает изменения из указанного удалённого репозитория, 
# а затем пытается слить их с текущей веткой.

git push
# используется для установления связи с удалённым репозиторием, 
# вычисления локальных изменений отсутствующих в нём, и 
# собственно их передачи в вышеупомянутый репозиторий

git remote
# служит для управления списком удалённых репозиториев. 
# Она позволяет сохранять длинные URL репозиториев в виде 
# понятных коротких строк, например «origin», так что вам 
# не придётся забивать голову всякой ерундой и набирать её 
# каждый раз для связи с сервером 

git help # справка по всем командам

```

[Git для новичков](https://habr.com/ru/articles/541258/)
---

# CI/CD

# Многопоточность

[Источник](https://radioprog.ru/post/1402)

## Определение

**Многозадачность (multitasking)** – свойство операционной системы или среды выполнения обеспечивать возможность параллельной (или псевдопараллельной) обработки нескольких задач.

**Многопоточность (multithreading)** – свойство платформы (например, операционной системы, виртуальной машины и т. д.) или приложения, состоящее в том, что процесс, порождённый в операционной системе, может состоять из нескольких потоков, выполняющихся «параллельно», то есть без предписанного порядка во времени. При выполнении некоторых задач такое разделение может достичь более эффективного использования ресурсов вычислительной машины.

**Процесс** – экземпляр программы во время выполнения;  
**Потоки** – ветви кода, выполняющиеся «параллельно», то есть без предписанного порядка во времени.

**Процесс** – это абстракция, реализованная на уровне операционной системы. Процесс был придуман для организации всех данных, необходимых для работы программы.  
**Процесс** – это просто контейнер, в котором находятся ресурсы программы:
- адресное пространство;
- потоки;
- открытые файлы;
- дочерние процессы;
- и т.д.;

**Поток** – это абстракция, реализованная на уровне операционной системы. Поток был придуман для контроля выполнения кода программы.

**Поток** – это просто контейнер, в котором находятся:
- счётчик команд;
- регистры;
- стек.

## Проблемы многопоточности


### Race condition

**Состояние гонки** – ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

Суть состояния гонки заключается в том, что итоговое состояние общего ресурса зависит от того, в каком порядке выполняются операции потоками или процессами. 
Если не предусмотрены механизмы синхронизации или взаимного исключения, то возникает конкуренция между потоками за доступ к ресурсу.

Примером состояния гонки может быть следующая ситуация: предположим, что два потока одновременно пытаются увеличить значение одной переменной на 1. 
Оба потока читают текущее значение переменной, увеличивают его и записывают новое значение. 
Однако, если оба потока прочитали старое значение одновременно, то они оба увеличат его на 1 и запишут обновленное значение, игнорируя вклад другого потока. 
В результате значение переменной будет увеличено только на 1, хотя должно было увеличиться на 2.

### Dead lock

**Deadlock** – ситуация, при которой несколько потоков находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать выполнение.

```c++
void fun1() // функция выполняющаяся в одном потоке
{
    mtx1.lock();    // блокировка мьютекса 
    
    mtx2.lock();    // блокировка мьютекса 

}


void fun2() // функция выполняющаяся в другом потоке 
{
    mtx2.lock();    // блокировка мьютекса 
    
    mtx1.lock();    // блокировка мьютекса 

}
```

Пример выше показывает ситуацию с взаимной блокировакой

### Live lock

**Livelock** – очень похож на deadlock, с той лишь разницей, что во время livelock’а потоки во время ожидания выполняют какие-то операции. Однако эти операции не имеют практического смысла, так как потоки несмотря на выполняемые операции и так не могут завершить свои задания. 

### Starvation

## Синтаксис

```c++
#include <thread>       // Подключение либы

this_thread::get_id();  // Индентификатор текущего потока
/*
    this_thread - это пространство имен группирует набор функций, которые обращаются к текущему потоку.
*/

std::thread th(/*указатель на функцию*/);
std::thread th(/*указатель на функцию*/, /*Параметры*/);
std::thread th(/*указатель на функцию*/, std::ref(/*Параметры*/)); // Для передачи параметров по ссылке
std::thread th(/*указатель на класс с перегрженными ()*/, /*Объект*/, /*Параметры*/);
std::thread th(&/*Название класса*/::/*название метода*/, /*Параметры*/);
std::thread th ([](){})

th.join();          // Текущий поток ждет поток th
th.detach();        // Продолжаем выполнение текущего потока не дожидаясь завершения th

std::mutext mtx;
mtx.lock();
/*
    участок кода который выполняется только при разрешении мьютексом
*/
mtx.unlock();

std::lock_guard<mutex> guard(mtx);

std::recursive_mutex rm;    // Рекурсивный мьютекс можно лочить любое количество раз
// но и разблочить его нужно столько же раз

rm.lock();
rm.lock();
rm.lock();

rm.unlock();
rm.unlock();
rm.unlock();

std::unique_lock ul(mtx);
std::unique_lock ul(mtx,std::defer_lock); // не вызывать lock у мьютекса


```

### Lock guard

Своего рода умный указатель для мьютекса. При создании вызывает mutex.lock(), а в деструкторе вызывает mutex.unlock();

### unique_lock 

При выходе из зоны видимости так же освобождает mutex.  
Можно вызвать unlock  вручную

[Цикл видео о этом](https://www.youtube.com/watch?v=NawpxG81RRk&list=PLQOaTSbfxUtAc_RpyDiWCHq0YTzLtVSD0)

# Процессы 

## Межпроцессное взаимодействие

### Shared memmory

### Pipes

### Сериализация

# Сети 

## OSI
*Open Systems Interconnection*

![OSI](https://github.com/CapSmoIIett/cplusplus/blob/main/images/osi_1.png)

По модели процесс передачи данных по сети происходит постепенно от одного уровня к другому. 
На каждом из них используются информация с прошлого уровня и определенные протоколы. 
Главными героями здесь выступают устройства отправителя и получателя, а также сами передаваемые данные. 
И как раз процесс обмена информации между устройствами определяет модель OSI. 

На физическом уровне информация предстает в виде битов, а на прикладном она отражается в более привычном для нас виде, в виде данных. 
Существует два процесса перехода от первого уровня к седьмому и наоборот. 
Первый – это инкапсуляция, когда данные отправляются с устройства и переводятся в биты. 
Второй – декапсуляция, обратный переход, когда биты трансформируются в данные.

### 1 Физический

Здесь происходит обмен оптическими, электрическими или радиосигналами между устройствами отправителя и получателя. 

На этом уровне железо не распознает данные в классическом для нас виде (картинки, текст, видео), но оно понимает биты (единицы и нули) и работает только с сигналами. 
Таким оборудованием выступают концентраторы, медиаконвертеры или репитеры. 
Здесь информация или биты передаются либо по проводам, кабелям, либо без них, например через Bluetooth, Wi-Fi.

### 2 Канальный 

Если в локальной сети находится более двух устройств, то необходимо определить, куда конкретно направлять информацию. 
Этим занимается как раз канальный уровень, принимающий на себя важную роль адресации. 

Второй уровень принимает биты и трансформирует их в кадры (фреймы). 
Здесь существуют MAC-адреса (Media Access Control), которые необходимы для идентификации устройств. 
На втором уровне происходит еще проверка на ошибки, и исправление информации, а также управление ее передачей. Этим занимается LLC (Logical Link Control).

### 3 Сетевой

На третьем уровне происходит маршрутизация трафика. 
Этим занимаются такие устройства, как роутеры или маршрутизаторы. 

На сетевом уровне работает протокол ARP (Address Resolution Protocol), который определяет соответствие между логическим адресом сетевого уровня (IP) и физическим адресом устройства (MAC). 
Здесь пересылаемая информация выступает уже в виде пакетов, состоящих из заголовка и поля данных.

Информация об известных IP и MAC-адресах хранится в виде таблицы (ARP-таблица) с данными, что позволяет устройствам не тратить время на повторную идентификацию. 

### 4 Транспортный

Четвертый уровень получает пакеты и передает их по сети. 
Он отвечает за установку соединения, надежность и управление потоком. 
Блоки данных делятся на отдельные фрагменты, размеры которых зависят от используемого протокола. 
Главными героями тут выступают 2 протокола TCP (Transmission Control Protocol) и UDP (User Datagram Protocol). 
В чем их отличие и когда их применять?

При транспортировке данных, наиболее восприимчивых к потерям, например, web-страницы, задействуется протокол [TCP](#tcpip) с установлением соединения. 
Он контролирует целостность информации, в данном случае нашей страницы, ибо потеря какого-то контента заставит задуматься пользователя о его полезности. 
Чтобы сделать передачу более эффективной и быстрой, транспортный уровень разбивает данные на более мелкие сегменты.

[UDP](#udp)-протокол используется с данными, для которых потери не так критичны, например, мультимедиа-трафик. 
Для них более заметна будет задержка, поэтому UDP обеспечивает связь без установки соединения. 
Во время передачи данных с помощью протокола UDP, пакеты делятся уже на автономные датаграммы. 
Они могут доставляться по разным маршрутам и в разной последовательности.

### 5 Сеансовый

Уровни с пятого по седьмой уже работают с чистыми данными. 
И здесь за дело берутся не сетевые инженеры, а разработчики.

Сеансовый уровень, исходя из названия, отвечает за поддержание сеанса или сессии. 
Он координирует коммуникацию между приложениями и отвечает за установление, поддержание и завершение связи, синхронизацию задач и сам обмен информацией. 
Примером для пятого уровня можно назвать созвон в Zoom или прямой эфир на YouTube. 
Во время сессии необходимо обеспечивать синхронизированную передачу аудио и видео для всех участников, а также поддерживать саму связь. 
За это как раз отвечают протоколы сеансового уровня (RPC, H.245, RTCP).

### 6 Уровень представления

Шестой уровень подготавливает информацию для последнего и преобразует (сжимает, кодирует, шифрует) их в понятный язык для пользователя или машины. 
Например, если вы отправляете картинку, то она сначала приходит в виде битов, а потом трансформируются в JPEG, GIF или другой формат.

### 7 Прикладной

Верхний уровень модели OSI – это прикладной. 
С помощью своих протоколов он отображает данные в понятном конечному пользователю формате. 
Сюда входят такие технологии, как HTTP, DNS, FTP, SSH и многое другое. 
Почти каждый человек ежедневно взаимодействует с протоколами прикладного уровня.

### Как это все работает?
Чтобы информация могла быть передана по сети от устройства к устройству, данные должны пройти семь кругов, а точнее уровней по модели OSI. 
Информация передается с уровня 7 вниз на уровень 1 от отправителя, а затем передается с уровня 1 на уровень 7 на устройстве получателя. 

Примером передачи данных по модели OSI является приложение электронной почты. 
Когда пользователь отправляет письмо, оно приходит на уровень представления с использованием определенного протокола (SMTP для исходящей электронной почты). 
Уровень представления сжимает информацию и отправляет сообщение на сеансовый, который открывает сессию для связи между устройством отправителя и исходящим сервером.

Далее вступает в силу транспортный уровень, где сегментируются полученные данные. 
Затем сетевой уровень разбивает сегменты на пакеты и отправляет их на канальный уровень, где они разбиваются на фреймы. 
Фреймы переходят на физический уровень, где информация преобразуется в биты и передается через физическую среду, ​​беспроводные соединения или кабели.

Когда сообщение доходит до получателя, происходит обратный процесс, где информация переходит из битовых единиц и нулей в сообщение на почте получателя. 
Как-то так.

[Это база. Сетевая модель OSI. Истоки](https://habr.com/ru/companies/serverspace/articles/689704/)

## TCP/IP
*Transmission Control Protocol (TCP) и Internet Protocol (IP)*

TCP/IP — сетевая модель передачи данных, представленных в цифровом виде. 
Модель описывает способ передачи данных от источника информации к получателю. 
В модели предполагается прохождение информации через четыре уровня, каждый из которых протоколом передачи.

Надежная передача потоков байт.  
Гарантия доставки данных.  
Сохранения порядка следования сообщений.  

Транспортная подсистема получает поток байт. 
Поток байт разбивается на сегменты, которые по отдельности отправляются.

| Уровни        | Протоколы             |
| ------------- |:---------------------:|
| Прикладной    | HTTP, RTSP, FTP, DNS  |
| Транспортный  | TCP, UDP, SCTP, DCCP  |
| Сетевой       | IP                    |
| Канальный     |Ethernet, IEEE 802.11, WLAN, SLIP, Token Ring, ATM и MPLS |

![Работа TCP](https://github.com/CapSmoIIett/cplusplus/blob/main/images/tcp_1.png)

В протоколе подтверждается не каждый сегмент, а несколько отправленных друг за другом(скользящее окно)

все сегменты нумеруются(номер байт).

[Протокол TCP](https://www.youtube.com/watch?v=CKUOb4htnB4)

## UDP
*User Datagram Protocol*

На транспортном уровне.

Особенности:
- Нет соединения
- нет гарантий доставки данных
- нет гарантий сохранения порядка

Преимущество UDP - скорость работы


[Протокол UDP](https://www.youtube.com/watch?v=CKUOb4htnB4)

### ICMP
*Internet Control Message Protocol — протокол межсетевых управляющих сообщений*
Cетевой протокол, входящий в стек протоколов TCP/IP. В основном ICMP используется для передачи сообщений об ошибках и других исключительных ситуациях, возникших при передаче данных, например, запрашиваемая услуга недоступна или хост, или маршрутизатор не отвечают. 
Также на ICMP возлагаются некоторые сервисные функции (services).

## Сокеты

### Win Socket

заголовки

```c++
#include "winsock.h" 
#include "winsock2.h"
```

инициализация

```c++
int WSAStartup( WORD wVersionRequested, (in) LPWSADATA lpWSAData (out) ); 

WSADATA ws;
//...
if (FAILED (WSAStartup (MAKEWORD( 1, 1 ), &ws) ) ) 
{
    // Error...
    error = WSAGetLastError();
    //...
}
```

создание сокета

```c++
SOCKET s;

SOCKET socket ( int af (in),          // протокол (TCP/IP, IPX...)
                int type (in),        // тип сокета (SOCK_STREAM/SOCK_DGRAM)
                int protocol (in)     // для Windows приложений может быть 0
              );

if (INVALID_SOCKET == (s = socket (AF_INET, SOCK_STREAM, 0) ) )
{
    // Error...
    error = WSAGetLastError();
    // ... 
}

устанавливаем соединение

int connect(SOCKET s,                             // сокет (наш сокет)
            const struct sockaddr FAR *name,  // адрес 
               int namelen                    // длинна адреса
           );

// Объявим переменную для хранения адреса 
sockaddr_in s_addr;

// Заполним ее:
ZeorMemory (&s_addr, sizeof (s_addr));
// тип адреса (TCP/IP)
s_addr.sin_family = AF_INET;
//адрес сервера. Т.к. TCP/IP представляет адреса в числовом виде, то для перевода 
// адреса используем функцию inet_addr.
s_addr.sin_addr.S_un.S_addr = inet_addr ("193.108.128.226"); 
// Порт. Используем функцию htons для перевода номера порта из обычного в //TCP/IP представление.
s_addr.sin_port = htons (1234);

// Дальше выполняем соединение:
if (SOCKET_ERROR == ( connect (s, (sockaddr *) &s_addr, sizeof (s_addr) ) ) )
{
    // Error...
    error = WSAGetLastError();
    // ... 
}
```

посылаем данные
```c++
int send(SOCKET s,              // сокет- отправитель
         const char FAR *buf,   // указатель на буффер с данными
         int len,               // длинна данных
         int flags              // флаги (может быть 0)
        );

if (SOCKET_ERROR == ( send (s, (char* ) & buff), 512, 0 ) ) 
{
    // Error...
    error = WSAGetLastError();
    // ... 
}
```
Флаги:
- MSG_DONTROUTE - указывает на то, что в отправляемое сообщение, не включатся информация о маршрутизации. 
Однако Winsock service provider может игнорировать этот флаг при доставке сообщения. Используется для отладки. 
Адрес назначения - локальный. То есть данные могут быть доставлены только на машины, соединенные напрямую.

- MSG_OOB (Out Of Band) - Сообщение является OOB данными.  
То есть, такое сообщение передаётся вне потока. Это значит, что при отправке сообщения, транспортный протокол не ждёт полного заполнения буфера, а отсылает сообщение немедленно.
Данный флаг можно использовать при передаче приоритетных данных. 
При использовании MSG_OOB, Winsock-приложения поддерживающие связь, должны заранее "договориться" об использовании этого флага.

принимаем данные
```c++
int recv(SOCKET s,         // сокет- получатель
         char FAR *buf,    // адрес буфера для приёма данных 
         int len,          // длинна буфера для приёма данных
         int flags         // флаги (может быть 0)
        );

int actual_len = 0;

if (SOCKET_ERROR == (actual_len = recv (s, (char* ) & buff), max_packet_size, 0 ) ) 
{
    // Error...
    error = WSAGetLastError();
    // ... 
}
```
Флаги:
- MSG_PEEK - Данные копируются в принимающий буфер, но из очереди сообщений не изымаются. Функция возвращает количество принятых на данный момент байт данных.

- MSG_OOB - Сообщение является OOB данными. (Out Of Band) То есть, такое сообщение передаётся вне потока. Это значит, что при отправке такого сообщения, транспортный протокол не ждёт полного заполнения TCP-буфера, а отсылает сообщение немедленно. Данный флаг можно использовать при передаче приоритетных данных. При использовании MSG_OOB, Winsock-приложения поддерживающие связь, должны заранее "договориться" о использовании этого флага.

закрываем соединение
```c++
int shutdown(SOCKET s,     // Закрываемый сокет
             int how       // Способ закрытия
           );

int closesocket(SOCKET s   // Закрываемый сокет
    );

closesocket (s);
```

Для того, что бы узнать IP адрес машины зная ёё имя, существует функция gethostbyname.

```c++
struct hostent FAR *gethostbyname(const char FAR *name );

hostent* d_addr; // Структура, в которую будет помещен IP адрес, // при возврате.
hostent* hn = gethostbyname ("www.Shelek.com");
//...

struct hostent {
   char FAR * h_name;               // Официальное имя машины
   char FAR * FAR * h_aliases;      // Массив альтернативных имен машины // (заканчивающийся 0)
   short h_addrtype;                // Тип адреса (AF_INET...)
   short h_length;                  // Длина адреса в байтах
   char FAR * FAR * h_addr_list;    // Список адресов (заканчивающийся 0)
};


sockaddr_in adr;
// ...
hostent* d_addr = gethostbyname ("www.Shelek.com");
adr.sin_addr.S_un.S_addr = *(DWORD* ) hn-h_addr_list[0];
// ...

struct HOSTENT FAR * gethostbyaddr(
    const char FAR *addr,     // Адрес машины (в сетевом виде)
    int len,                  // Длинна адреса
    int type                  // Тип адреса
);

DWORD a = inet_addr ("192.168.0.4"); // Адрес машины в сетевом формате
   hn = gethostbyaddr ((char* )&a, 4, AF_INET);
```

Функция ioctlsocket.
Функция ioctlsocket позволяет менять/получать режим ввода/вывода конкретного сокета.
```c++
int ioctlsocket(SOCKET s,              // Сокет [in]
                long cmd,              // Комманда [in]
                u_long FAR *argp       // Параметр/значение [in/out]
               );

BOOL l = TRUE;
if (SOCKET_ERROR == ioctlsocket (s, FIONBIO, (unsigned long* ) &l) )
{
    // Error
   int res = WSAGetLastError ();
   return -1;
}
```

Функция select
Функция slect позволяет определить текущее состояние одного или более сокетов. 
То есть, из какого-то входящего множества сокетов, она формирует выходящее множество сокетов, готовых к операциям чтения/записи/....

```c++
int select(int nfds,                         // Не используется (оставлен для совместимости)
           fd_set FAR *readfds,              // множество сокетов, проверяемых на готовность к чтению
           fd_set FAR *writefds,             // множество сокетов, проверяемых на готовность к отсылке
           fd_set FAR *exceptfds,            // множество сокетов, проверяемых на ошибку/OOB данные
           const struct timeval FAR *timeout // Таймаут проверки
);

FD_CLR (s, *set) -Удаляет дескриптор s из set.
FD_ISSET(s, *set) - Возвращает ненулевое значение, если s присутствует в set. Иначе, возвращает ноль.
FD_SET(s, *set) - добавляет s к set.
FD_ZERO(*set) - Очищает множество set

struct timeval {
   long tv_sec;  // секунды
   long tv_usec; // микросекунды
};
```

С помощью функции select и этого набора макросов, мы можем проверять конечное множество сокетов на готовность к считыванию/отсылке данных, выполнения connect, на предмет входящих соединений, наличия OOB сообщений и т.п. 
На данном этапе нас интересует проверка сокета на возможность считывания данных, поэтому пока ограничимся самым простым вызовом select. 
Для этого нам необходимо поместить наш сокет в множество на которое будет указывать readfds (в примере это read_s), задать timeout и выполнить select.

```c++
// ...

fd_set read_s; // Множество
timeval time_out; // Таймаут

FD_ZERO (&read_s); // Обнуляем мнодество
FD_SET (s, &read_s); // Заносим в него наш сокет
time_out.tv_sec = 0;time_out.tv_usec = 500000; //Таймаут 0.5 секунды.
if (SOCKET_ERROR == (res = select (0, &read_s, NULL, NULL, &time_out) ) ) return -1;

if ((res!=0) && (FD_ISSET (s, &read_s)) ) // Использую FD_ISSET только для примера! :)
{
    // Получаю данные
}
// ...
```

[Winsock для всех (часть 1)](https://club.shelek.ru/viewart.php?id=35)
[Winsock для всех (часть 2)](https://club.shelek.ru/viewart.php?id=36)
[Winsock для всех (часть 3)](https://club.shelek.ru/viewart.php?id=37)

---

# ОС

## Жизнь программы

Выполнение любого процесса жизненного цикла предполагает наличие результата, в явном или неявном виде.

#### Design-time

Программа появляется в голове программиста. 
Но так как это время абстрактно, примем за время появления программы - момент создания минимального запускаемого кода.

#### Compile-time

В результате выполнения процесса компиляции мы получаем компилят (то есть непосредственный результат обработки нашего исходного кода).

#### Load-time

После получения компилята, над ним, сразу или отложенно должен быть исполнен процесс связывания или линковки. Так как компилят обычно хранится в файле, то возникает время загрузки

#### Link-time

Обычно, линковка необходима, так как компилятор всегда производит компилят для одного модуля для непосредственного исполнения на целевой машине. 
Однако в реальной модульной системе на машине одновременно будут исполнены несколько модулей.

#### Init, Run, Close-time

Запуск и дальнейшая работа. Наиболее известные широкой публике этапы. Представлены временем инициализации (init-time) и временем исполнения (run-time). 
В сущности, результат работы этого этапа жизненного цикла и является обычно непосредственной целью написания программы.

Можно дополнительно выделить время завершения работы программы (close-time). 
Однако сейчас все три времени работы обычно принято называть run-time, а логическое деление на три этапа реализовывать уже в рамках клиентского программного кода.

#### Death-time

Отдельным важным временем жизни программы является посмертное время (death-time), в которое, вопреки распространенным представлениям тоже является частью жизненного цикла программы. 
Целью работы программы обычно является некий результат, обычно зависящий от входных данных, программы строятся с применением методов, позволяющих итеративно обрабатывать входные данные и производить выходные данные, которые могут быть поданы на вход следующей итерации. 
Например записывать итоги работы в бд

[Концепция жизни программы](https://habr.com/ru/articles/313934/)

---

# Библиотеки и фреймворки

## Boost

## Qt

## gtest/gmoch

# Практики разработки()

# SQ()L

