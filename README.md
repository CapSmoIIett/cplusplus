# С++

Этот репозиторий представляет мою позу знаний по С++

В качестве его основы я взял этот [roadmap](https://github.com/salmer/CppDeveloperRoadmap), от которого я отталкивался

![карта с++](https://github.com/CapSmoIIett/cplusplus/blob/main/images/%D0%9A%D0%B0%D1%80%D1%82%D0%B0%20%D0%A1%2B%2B.png)

# Содержание:


# [Синтаксис](syntax)
## [Идиомы](idioms)
# [STL](STL)


# Синтаксис
<a name="syntax"></a> 

## Базовые операции 

### Арифметические операции

#### Инкремент и декремент

Префиксный - увеличивает значение до выполенения кода в строке где его вызвали.  
Постфиксный - после выполнения кода в строке в которой его вызвали.
```diff
! Постфиксный немного медленее т.к. возвращает копию переменой которую инкрементировал.
```
[Источник](https://www.cyberforum.ru/cpp-beginners/thread1297462.html)

Операторы могут быть *левоассоциативными* - выполняются слева направо и *правоассоциативными* - выполняются справа налево.  
Большинство операторов левоассоциативны.   
Правоассоциативными операторами являются все унарные операторы, различные операторы присваивания и условный оператор.
  
---

### Логические операции 

---

### Циклы

---

### По битовые операции 

\<< сдвиг влево  
\>> сдвиг вправо  
\~ поразрядная инверсия  
\| поразрядное ИЛИ  
\& поразрядное И  
\^ поразрядное исключающее ИЛИ  

Если нужно записывать определенные биты, не стирая другие:

Чтобы записать единицу в бит n:
```c++
x |= (1 << n);
```

Чтобы записать ноль в бит n:
```c++
x &= ~(1 << n);
```

Если нужно инвертировать состояние бита:
```c++
x ^= (1 << n);
```

Если нужно прочитать отдельный бит:
```c++
unsigned char x = (1 << 2) | (1 << 3) | (1 << 7);  
if (x & (1 << 2)) {  /* во второй бит вписана единица */ }  
if (x & (1 << 3)) {  /* в третий бит вписана единица */ }  
if (x & (1 << 7)) {  /* в седьмой бит вписана единица */ }  
```

Если нужно определить, что в X на N-й позиции:
```c++
bool b = (bool((1 << n)  &  x))
```

Если нужно обнулить один или несколько битов:
```c++
int x = 58;       // 00111010
int y = x & 0x0F; // 00001010

//или

x = x & (~((1<<3)|(1<<5)|(1<<6))); //обнуляем третий, пятый и шестой биты
```

Если нужно установить заданные биты в единицу. Используют оператор |
```c++
int x = 155
x = x | 4;     //устанавливаем в единицу второй бит переменной x
```

Сдвигает число на n разрядов влево
```c++
unsigned char x = 3;  //0b00000011
x = x << 3;           //0b00011000 (24)
```

Сдвиг вправо >>
```c++
unsigned char x = 255;  //0b11111111
x = x >> 3;             //0b00011111 (31)
```

[Источник](https://volstr.ru/?p=36)

---

## Функции

## Типы данных
## Указатели и ссыдки
### Ссылки
### Умные казатели 



### Row указатели (сырые или обычные)
## Организация кодовой базы
## Структуры и классы

Главное различие между классом и структурой в с++, по умолчанию область видимости полей в структуре - public, а у класса - private.

## Библиотеки и взаимодействие с ними
## Обработка ошибок

## Концепции языка

## Шаблоны

## Идиомы
<a name="idioms"></a> 

### RAII
*Resource Acquisition Is Initialization - Получение ресурса есть инициализация*

Идиома очень простая и кратко описывается следующим образом: в конструкторе объект получает доступ к какому либо ресурсу (например, открывается файл или устанавливается соединение по сети к базе данных) и сохраняет описатель ресурса в закрытый члена класса, а при вызове деструктура этот ресурс освобождается (закрывается файл или соединение к БД). При объявлении объекта данного класса на стеке происходит и его инициализация с вызовом конструктора, захватывающий ресурс. При выходе из области видимости объект выталкивается из стека, но перед этим вызывается деструктор объекта, который и освобождает захваченный ресурс.

[Источник](https://habr.com/ru/sandbox/21603/)

Основные моменты:

1. Обращение к ресурсу происходит в один этап. Либо мы получаем готовый полностью функциональный объект сразу, либо не получаем ничего.
2. Безопасность по отношению к исключению. Например, если после создания объекта и обращения к ресурсу произойдет исключение и мы перейдем к обработчику исключения, мы можем быть уверены что ресурс освободится без нашего участия. Даже если ресурсов несколько, мы уверены что все они будут корректно освобождены. В противном случае, если захватывать и освобождать ресурс вручную, то при возникновении исключения нужно учитывать, какие ресурсы уже захвачены, а какие – нет, и освобождать только использованные ресурсы, что не слишком просто.
3. Идиома очень удобна, когда нужно отслеживать важные ресурсы, а при этом сопровождение кода оставляет желать лучшего.
4. Часто при использовании нескольких ресурсов освобождать их следует в обратном порядке. При использовании идиомы RAII, вследствие того что объекты с захваченными ресурсами располагаются на стеке, их уничтожение происходит в обратном порядке, что как правило и является желательным.
5. Поддержка принципа DRY (Don’t Repeat Yourself). Код инициализации и освобождения ресурса содержится только в одном месте. Нет необходимости копировать и вставлять код инициализации в каждое место в программе где это необходимо. Достаточно просто создать объект.
6. При необходимости использовать дополнительные параметры для обращения к ресурсу (например, логин и пароль к БД) эти параметры могут быть переданы в качестве аргументов конструктора.
7. Накладные расходы при простейшей реализации обращения к ресурсу минимальны. В С++, как правило, при оптимизации компилятор реализует невиртуальные конструкторы и деструкторы в виде inline-функций.
8. Данная идиома применима только в языках с предсказуемым временем жизни объекта. Сюда относится, например, С++, а также языки с сборщиком мусора, где время жизни объекта определяется количеством ссылок на него, такие как Objective C.
9. Эта идиома неприменима в таких языках как Java или С#, где невозможно предсказать когда объект будет удален.

---

### pimpl

*pointer to implementation - указатель на реализацию*

Идиома **pimpl** - полезна в тех случаях, когда нам нужно что-то скрыть. Она обеспечивает еще более глубокий вид инкапсуляции, которая маскирует не просто реализацию, а также все ее зависимости.
Нужна для:
1. Для того, что бы была возможность изменять реализацию скрываемого класса без перекомпиляции остального кода, так как закрытые члены хоть и недоступны извне никому, кроме функций-членов и друзей, но видимы всем, кто имеет доступ к определению класса. Изменение определения класса приводит к необходимости перекомпиляции всех пользователей класса
2. Для сокрытия имен из области видимости. Закрытые члены хоть и не могут быть вызваны кодом вне класса, тем не менее они участвуют в поиске имен и разрешении перегрузок
3. Для ускорения времени сборки, так как компилятору не нужно обрабатывать лишние определения закрытых типов

Как мы этого добиваемся?
Переносим #include <название библтотеки> из .h в .cpp.
В .h дописываем необзодимый include

До:
```c++
// .h
#include "HideClass.h"

class A 
{
public:
    void fun();

private:
    HideClass b;
}


// .cpp
void A::fun()
{ /*Do something*/}
```

После:
```c++
// .h
class HideClass;

class A
{
public:
    A();
    ~A();
    void fun();

private:
    HideClass* b;
}


// .cpp
#include "HideClass.h"

A::A():
    b (new HideClass)
{ /*Do something*/}

A::~A()
{ delete b; }

void A::fun()
{ /*Do something*/}
```

В С++, в случае изменений в классе (даже в закрытых функциях членах) все пользователи данного класса должны быть перекомпилированы. 
Для избежания подобных зависимостей используется указатель на функции члены, реализацию которых необходимо скрыть.
Два основных недостатка заключаются в следующем:
1. Каждое создание объекта требует динамического выделения памяти для объекта, на который ссылается указатель
2. Использование нескольких уровней косвенности (как минимум — один) для доступа к членам скрытого объекта

Что же можно попробовать скрыть?

1. Только скрытые данные-члены
2. Все скрытые данные-члены и функции-члены. К сожалению, скрыть виртуальную функцию невозможно, так как она должна быть видима для производных классов. Также в закрытом классе может понадобиться ссылка на открытый класс для использования его функций
3. Закрытые и защищенные члены. К сожалению, защищенные члены скрыть нельзя, так как они должны быть доступны производным классам
4. Весь класс. Преимущество заключается в том, что закрытому классу не нужен указатель на открытый класс. С другой стороны, мы лишаемся возможностей наследования

(Сам до конца не понимаю указанное выше)

И еще: 
```c++
// .h
class HideClass;

class A
{
public:
    A();
    ~A();
    void fun();

private:
    int hideClassSize = 42;
    char hideClassObj[hideClassSize];
}


// .cpp
#include "HideClass.h"

A::A()
{
    assert(hideClassSize >= sizeof(HideClass));
    new(&hideClassObj[0]) HideClass;
}

A::~A()
{
    (reinterpret_cast<HideClass *> (&hideClassObj[0]))->~HideClass();
}

void A::fun()
{ /*Do something*/}
```

Кодом выше получилось избавиться отдинамического выделения памяти.

Нам удалось избавиться от объявления класса UnixSocketImpl в заголовочном файле GeneralSocket, и избавиться от динамического выделения памяти. Взамен мы получили ряд существенных недостатков:

1. С++ — язык со строгой типизацией, и данное ухищрение – попытка обойти ограничения языка
2. Проблемы с выравниванием памяти. Данный способ не гарантирует что память будет выравнена должным образом для всех членов UnixSocketImpl. Решение, которое не гарантирует полную переносимость, но все же работает в большинстве случаев – использование union:

### Non-Copyable/Non-Moveable

(Как я понял) Если есть класс который нельзя копировать и перемещать то просто удаляем его конструкторы копирования.

```c++
class NonCopyable
{
  public: 
    NonCopyable (const NonCopyable &) = delete;
    NonCopyable & operator = (const NonCopyable &) = delete;

  protected:
    NonCopyable () = default;
    ~NonCopyable () = default; /// Protected non-virtual destructor
};
class CantCopy : private NonCopyable
{};
```
[Источник](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-copyable_Mixin)
 
 ---

### Erase-Remove

Идиома **remove-erase idiom** призвана решить проблему удаления элементов из контейнера, поскольку данная проблема может представлять нетривиальную задачу, чреватую возникновением ошибок. 
Данная идиома предполагает применение алгоритма remove() или remove_if(), за которым следует вызов функции erase() контейнера.

При применении алгоритмов remove() и remove_if() те элементы, которые надо сохранить, помещаются в начало контейнера, а функции remove() и remove_if() возвращают итератор на первый удаляемый элемент. 
Затем этот итератор передается в функцию erase(), которая собственно и удаляет элементы.

[Источник](https://metanit.com/cpp/tutorial/16.4.php#:~:text=%D0%98%D0%B4%D0%B8%D0%BE%D0%BC%D0%B0%20remove%2Derase%20idiom%20%D0%BF%D1%80%D0%B8%D0%B7%D0%B2%D0%B0%D0%BD%D0%B0,%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%20erase()%20%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0.)

---

### Copy and swap

Когда нужно изменить состояние одного или нескольких объектов, и на любом этапе модификации может возникнуть ошибка, для создания кода, устойчиваого к ошибкам, может применяться **идиома копирования и замены (copy-and-swap idiom)**. 
Суть данной идиомы состоит в следующей последовательности действий:
1. Создаем копию объекта(ов)
2. Изменяем копию. При этом оригинальные объекты остаются нетронутыми
3. Если все изменения прошли успешно, заменяем оригинальный объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то оригинальный объект не заменяется.

[Источник](https://metanit.com/cpp/tutorial/13.1.php)

---

### Copy on write

Копирование объекта иногда может привести к снижению производительности. 
Если объекты часто копируются, но редко изменяются позже, копирование при записи может обеспечить значительную оптимизацию. 
Для реализации копирования при записи используется интеллектуальный указатель на реальное содержимое для инкапсуляции значения объекта, и при каждой модификации проверяется счетчик ссылок на объект; 
если на объект ссылаются более одного раза, перед модификацией создается копия содержимого.

Я понимаю это следующим образом:  
- много умных указателей на один элемент
- если хотим что-то поменять в данных по указателю для этого создаем его копию и работаем сней ( остальные умные указатели все еще указывают на оригинальный объект)

---

### CRTP

**Curiously Recurring Template Pattern (CRTP)** идиома языка C++, название которой можно примерно перевести как Странно рекурсивный шаблон или Странно повторяющийся шаблон, часто просто Рекурсивный Шаблон, состоящая в том, что некоторый класс X наследуется от шаблона класса, использующего X как шаблонный параметр.

[Классно работает с паттерном мост](https://habr.com/ru/articles/543098/)

---

## Стандарты

# ООП

**Инкапсуляция** - механизм позволяющий связывать данные и методы работающие с этими данными в единый объект (использование this для обращения к полям класса)

**Наследование** - концепция согласно которой абстрактный тип данных может наследовать данные и функциональность некоторого существующего типа

**Полиморфизм** - способность функции обрабатывать данные разных типов.  
Перегрузки - вид полиморфизма (*Ad hoc* полиморфизм или специальный полиморфизм)
Инкапсуляция с наследованием нужны для реализации полиморфизмах, сами по себе они бесполезны и даже вредны

**Абстрактный класс** -  базовый класс, который не предполагает создания экземпляров (абстрактный класс объявляется включением хотя бы одной чистой виртуальной функции, типа virtual _сигнатура_функции_ =0;)

**Интерфейс** — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.

#### виртуальный конструктор
Виртуальный **конструктор** невозможен, так как на момент его вызова объекта ещё просто не существует - ещё даже не существует указателя.

Но если бы теоретически "виртуальный конструктор" существовал, то зачем он мог бы быть нужен? Самая простая причина - десериализация. Представим себе функцию/метод, которая на вход получает XML/JSON и каким-то магическим образом догадывается, какой объект был там сериализован, и возвращает объект нужного типа. Более того, в Java это используется... Просто называется по-другому. А называется это Фабричный метод.


#### Виртуальный деструктор
**Дeструктор** полиморфного базового класса должен объявляться виртуальным. Только так обеспечивается корректное разрушение объекта производного класса через указатель на соответствующий базовый класс.


[Источник](https://www.youtube.com/watch?v=BHNt1fcg8iw)

---

# Патерны

[Сайт с патернами](https://refactoring.guru/ru/design-patterns/catalo)


## Порождающие

### Адаптер
*Wrapper, Обёртка, AdapterI*

**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.  
Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.

Применение:  
- Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.

---

### Мост
*Bridge*

Пример:  
У вас есть класс геометрических Фигур, который имеет подклассы Круг и Квадрат. Вы хотите расширить иерархию фигур по цвету, то есть иметь Красные и Синие фигуры. Но чтобы всё это объединить, вам придётся создать 4 комбинации подклассов, вроде СиниеКруги и КрасныеКвадраты.  
Паттерн Мост предлагает заменить наследование агрегацией или композицией. Для этого нужно выделить одну из таких «плоскостей» в отдельную иерархию и ссылаться на объект этой иерархии, вместо хранения его состояния и поведения внутри одного класса.

**Мост** — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

---

## Структурные 

## Поведеньческие

---

# Алгоритмы и структуры данных

# STL
<a name="STL"></a> 

## Контейнеры

*или коллекции*

![алгоритм выбора контейнера](https://github.com/CapSmoIIett/cplusplus/blob/main/images/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B.png)

![скорости работы контейнеров](https://github.com/CapSmoIIett/cplusplus/blob/main/images/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%B3%D0%B5%D1%80%D1%8B_%D1%81%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D1%8C%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B.jpg)

### Контейнеры последовательности:

### Array

Контейнер array  представляет аналог массива. Имеет фиксированный размер.
Для создания объекта array в угловых скобках после названия типа необходимо передать его тип и размер:

```c++
std::array<int, 5> numbers; 
```

В array-е все объекты инициальизируются сразу. 
По правилам C++ в массиве инициализация объектов происходит слева направо, уничтожение справа налево.

Если у объекта array тривиальный конструктор/деструктор (совсем ничего не делает), то кроме выделения памяти ничего не происходит.

![устройство array](https://github.com/CapSmoIIett/cplusplus/blob/main/images/array_1.png)

### Vector

vector — коллекция элементов, сохраненных в массиве, изменяющегося по мере необходимости размера (обычно, увеличивающегося);

vector - реализует динамический массив. 
Размер вектора — это фактическое число элементов, а объём — количество используемой им памяти. 
Если при вставке в вектор новых элементов, его размер становится больше его объёма, происходит перераспределение памяти. Как правило, это приводит к тому, что вектор выделяет новую область хранения, перемещая элементы и свободные старые области в новый участок памяти. 
Поскольку адреса элементов в течение этого процесса меняются, любые ссылки или итераторы элементов в векторе могут стать недействительными. Использование недействительных ссылок приводит к неопределённому поведению.

устройство вектора:

Выделаяет память в куче. 
Хранит указатели на начало данных, конец данных и следующую ячейку памяти после выделенной под вектор.
Объект в заранее аллоцированной памяти создается с помощью конструкции [placement new](https://www.geeksforgeeks.org/placement-new-operator-cpp/). 
А начиная с C++11 с вводом perfect [forwarding](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F_%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0_(C%2B%2B)) новый объект для вектора можно создавать in-place (с помощью метода emplace/emplace_back)

.size() - количество объяектов в векторе.  
.capacity() - под какое количество объектов зарезервированна память.

![устройство вектора](https://github.com/CapSmoIIett/cplusplus/blob/main/images/vector_1.png)

вставка нового элемента:

![вставка нового элемента](https://github.com/CapSmoIIett/cplusplus/blob/main/images/vector_2.png)

вставка нового элемента, в случае когда размер становится больше объема:

при нехватке места ветор увеличивается в 2 раза.

![вставка нового элемента, в случае когда размер становится больше объема](https://github.com/CapSmoIIett/cplusplus/blob/main/images/vector_3.png)

### Deque

Это контейнер с быстрым добавлением объектов в начало и в конец.
Вся память разбивается на несколько кусков памяти (чанков) одинаковой величины.

![устройство deque](https://github.com/CapSmoIIett/cplusplus/blob/main/images/deque_1.png)

Указатели на чанки находятся в контейнере, похожем на вектор (с мелкими отличиями).
Получение ссылки на объект проводится через 2 разыменования (вместо 1 у std::vector).

Если нельзя добавить объект в начало/конец, то сначала аллоцируется новый чанк памяти. 
В худшем случае аллокаций будет два, потому что может понадобиться реаллокация контейнера указателей на чанки.

Плюс контейнера в том, что при добавлении новых объектов в начало/конец никакие существующие ссылки/указатели на другие объекты контейнера не инвалидируются.

### forward_list

Это однонаправленный список - самая простая реализация списка. Список состоит из вершин.
Вершина списка это сам объект и указатель на следующую вершину (указатель принимает значение nullptr, если объект последний в списке).

Контейнер поддерживает быструю вставку и удаление объектов в любом месте, потому что для этого понадобится только правка next_ptr у вершины слева.
Впрочем, "быстрая вставка" относится исключительно к алгоритмической сложности.
Aллокация памяти для новой вершины может быть небыстрой.

Быстро получить N-й объект нельзя, для этого нужно пройтись от корневой вершины по next_ptr N раз.
Размер списка тоже можно узнать только пройдя по всем next_ptr, пока не увидим nullptr.
У контейнера даже нет метода .size().

![устройство forward_list](https://github.com/CapSmoIIett/cplusplus/blob/main/images/forward_list_1.png)

### List

Это более сложная организация списка.
Она имеет все те же свойства, как у std::forward_list, но вершины дополнительно могут ссылаться на предыдущие вершины, и есть быстрое добавление в конец списка.

![устройство list](https://github.com/CapSmoIIett/cplusplus/blob/main/images/list_1.png)

.size() - есть

### Контейнеры-адаптеры

Некоторые контейнеры не имеют хитрого внутреннего устройства, и их функционал базируется на функционале какого-нибудь другого контейнера.

В них используется инкапсулированный объект контейнера в качестве базового контейнера, представляя определенный набор функций членов для доступа к его элементам. 

Базовым контейнером может быть любой из стандартных шаблонов класса контейнера или какой-либо другой специально разработанный класс контейнера. 

В STL таких контейнеров три: (stack, queue, priority_queue)

### Stack

Класс std::stack<T> представляет стек - контейнер, который работает по принципу LIFO (last-in first-out или "последний вошел — первым вышел") — первым всегда извлекается последний добавленный элемент.
Стек можно сравнить со стопкой предметов, например, стопкой тарелок - тарелки добавляются сверху, каждая последующая тарелка кладется поверх предыдущей.
А если надо взять тарелку, то сначала берется та, которая в самом верху (которую положили самой последней).

базовый контейнер по умолчанию (deque).

В базовом контейнеры должны быть реализованны:
- empty
- size
- back
- push_back
- pop_back

[источник](https://cplusplus.com/reference/stack/stack/)

### Queue

Адаптивынй контейнер для работы по принципу FIFO (первым пришел — первым вышел), где элементы вставляются в один конец контейнера и извлекаются из другого.

базовый контейнер по умолчанию (deque).

Базовый контейнер должен поддерживать как минимум следующие операции:
- empty
- size
- front
- back
- push_back
- pop_front

### priority_queue

priority_queue представляет очередь приоритетов - контейнер, который, как и станлдартная очередь, работает по принципу FIFO.
При добавлении элементов в очередь приоритетов применяется функция компаратора, которая сравнивает добавляемые элементы и располагает их в очереди в определенном порядке.

Вставиви в pq следующие значения: { 2, 10, 4, 8, 6, 9 };
получим: {10, 9, 8, 6, 4, 2}

### ассоциативные контейнеры

### Set

Контейнер, в котором хранятся уникальные элементы в определенном порядке.

В set значение элемента также является его идентификатором (значение является ключом типа T), и каждое значение должно быть уникальным. 
Значение элементов в set нельзя изменить после добавления в контейнер (элементы всегда const), но их можно вставлять или удалять из контейнера.

Внутренне элементы в set всегда отсортированы в соответствии с определенным строгим критерием слабого упорядочивания, указанным его внутренним объектом сравнения (типа Compare).

Контейнеры set обычно медленнее контейнеров unordered_set при доступе к отдельным элементам по их ключу, но они позволяют прямую итерацию по подмножествам в соответствии с их порядком.

set обычно реализованы в виде бинарных деревьев поиска.


Свойства контейнеров:

- Ассоциативные.
Элементы в ассоциативных контейнерах идентифицируются по ключу, а не по их абсолютной позиции в контейнере.

- Упорядоченные. 
Элементы в контейнере всегда следуют строгому порядку. Все вставленные элементы занимают определенную позицию в этом порядке.

- Множество (Set). 
Значение элемента также является ключом, используемым для его идентификации.

- Уникальные ключи. 
Ни одни два элемента в контейнере не могут иметь эквивалентные ключи.

- Allocator-aware.
Контейнер использует объект аллокатора для динамической обработки своих потребностей в памяти.

### Multiset

Мультимножества (Multiple-key set) - это контейнеры, которые хранят элементы в определенном порядке, где несколько элементов могут иметь эквивалентные значения.

В мультимножестве значение элемента также является его идентификатором (значение является ключом типа T). Значение элементов в мультимножестве нельзя изменить после добавления в контейнер (элементы всегда const), но их можно вставлять или удалять из контейнера.

Внутренне элементы в мультимножестве всегда отсортированы в соответствии с определенным строгим критерием слабого упорядочивания, указанным его внутренним объектом сравнения (типа Compare).

Контейнеры мультимножества обычно медленнее контейнеров unordered_multiset при доступе к отдельным элементам по их ключу, но они позволяют прямую итерацию по подмножествам в соответствии с их порядком.

Мультимножества обычно реализованы в виде бинарных деревьев поиска.

Свойства контейнеров:

- Ассоциативные.
Элементы в ассоциативных контейнерах идентифицируются по своему ключу, а не по абсолютной позиции в контейнере.

- Упорядоченные. 
Элементы в контейнере всегда следуют строгому порядку. Все вставленные элементы занимают определенную позицию в этом порядке.

- Множество (Set).
Значение элемента также является ключом, используемым для его идентификации.

- Множество с множественными эквивалентными ключами. 
В контейнере может быть несколько элементов с эквивалентными ключами.

- Allocator-aware.
Контейнер использует объект аллокатора для динамической обработки своих потребностей в памяти.

### Map

Карты (Map) - это ассоциативные контейнеры, которые хранят элементы, состоящие из комбинации значения ключа и значения отображаемого элемента, следуя определенному порядку.

В map ключи обычно используются для сортировки и уникальной идентификации элементов, а значения отображают содержимое, связанное с этим ключом. Типы ключа и отображаемого значения могут отличаться и объединены в типе-члене value_type, который является типом пары, объединяющей оба значения:

```cpp
typedef pair<const Key, T> value_type;
```
Внутренне элементы в map всегда отсортированы по ключу в соответствии с определенным строгим критерием слабого упорядочивания, указанным его внутренним объектом сравнения (типа Compare).

Контейнеры map обычно медленнее контейнеров unordered_map при доступе к отдельным элементам по их ключу, но они позволяют прямую итерацию по подмножествам в соответствии с их порядком.

Значения отображаемых элементов в map могут быть получены напрямую по соответствующему ключу с использованием оператора квадратных скобок (operator[]).

map обычно реализованы в виде бинарных деревьев поиска.

Свойства контейнеров:

- Ассоциативные.
Элементы в ассоциативных контейнерах идентифицируются по ключу, а не по их абсолютной позиции в контейнере.

- Упорядоченные.
Элементы в контейнере всегда следуют строгому порядку. Все вставленные элементы занимают определенную позицию в этом порядке.

- Карта (Map).
Каждый элемент ассоциирует ключ с отображаемым значением: ключи предназначены для идентификации элементов, основное содержимое которых является отображаемым значением.

- Уникальные ключи. 
Ни одни два элемента в контейнере не могут иметь эквивалентные ключи.

- Allocator-aware. 
Контейнер использует объект аллокатора для динамической обработки своих потребностей в памяти.

### Multimap

Мультимапы (Multiple-key map) - это ассоциативные контейнеры, которые хранят элементы, состоящие из комбинации значения ключа и значения отображаемого элемента, следуя определенному порядку, где несколько элементов могут иметь эквивалентные ключи.

В multimap ключи обычно используются для сортировки и уникальной идентификации элементов, а значения отображают содержимое, связанное с этим ключом. Типы ключа и отображаемого значения могут отличаться и объединены в типе-члене value_type, который является типом пары, объединяющей оба значения:

Внутренне элементы в multimap всегда отсортированы по ключу в соответствии с определенным строгим критерием слабого упорядочивания, указанным его внутренним объектом сравнения (типа Compare).

Контейнеры multimap обычно медленнее контейнеров unordered_multimap при доступе к отдельным элементам по их ключу, но они позволяют прямую итерацию по подмножествам в соответствии с их порядком.

multimap обычно реализованы в виде бинарных деревьев поиска.

Свойства контейнеров:

- Ассоциативные.
Элементы в ассоциативных контейнерах идентифицируются по своему ключу, а не по абсолютной позиции в контейнере.

- Упорядоченные.
Элементы в контейнере всегда следуют строгому порядку. Все вставленные элементы занимают определенную позицию в этом порядке.

- Карта (Map).
Каждый элемент ассоциирует ключ с отображаемым значением: ключи предназначены для идентификации элементов, основное содержимое которых является отображаемым значением.

- Множество эквивалентных ключей.
В контейнере может быть несколько элементов с эквивалентными ключами.

- Allocator-aware. 
Контейнер использует объект аллокатора для динамической обработки своих потребностей в памяти.

### Unordered set

Unordered Set (Неупорядоченное множество) - это контейнер, который хранит уникальные элементы в произвольном порядке и позволяет быстро получать отдельные элементы на основе их значения.

В unordered_set значение элемента одновременно является его ключом, который уникально идентифицирует его. Ключи неизменяемы, поэтому элементы в неупорядоченном множестве не могут быть изменены после размещения в контейнере. Однако, элементы могут быть вставлены и удалены из множества.

Внутренне элементы в unordered_set не отсортированы по какому-либо определенному порядку, но они организованы в корзины (buckets) в зависимости от их хэш-значений, что позволяет быстро получать отдельные элементы напрямую по их значениям (с постоянной средней сложностью по времени).

unordered_set обычно работают быстрее, чем упорядоченные множества, при доступе к отдельным элементам по их ключу, хотя они в целом менее эффективны для итерации по подмножеству элементов.

### Unordered_multiset


Unordered Multiset (Неупорядоченный мультимножество) - это контейнер, который хранит элементы в произвольном порядке, позволяя быстро получать отдельные элементы на основе их значения, подобно неупорядоченному множеству (unordered_set), но позволяющий различным элементам иметь эквивалентные значения.

В unordered_multiset значение элемента одновременно является его ключом, используемым для его идентификации. Ключи неизменяемы, поэтому элементы в unordered_multiset не могут быть изменены после размещения в контейнере. Однако, элементы могут быть вставлены и удалены из мультимножества.

Внутренне элементы в unordered_multiset не отсортированы по какому-либо определенному порядку, но они организованы в корзины (buckets) в зависимости от их хэш-значений, что позволяет быстро получать отдельные элементы напрямую по их значениям (с постоянной средней сложностью по времени).

Элементы с эквивалентными значениями группируются в одну корзину и таким образом, что итератор (см. equal_range) может перебирать их все.

Итераторы в контейнере являются по крайней мере прямыми итераторами (forward iterators).

Обратите внимание, что этот контейнер не определен в своем собственном заголовочном файле, но использует заголовочный файл <unordered_set> вместе с неупорядоченным множеством (unordered_set).

### Unordered map


Unordered Map  - это ассоциативный контейнер, который хранит элементы, состоящие из комбинации ключевого значения и отображаемого значения, и позволяет быстро получать отдельные элементы на основе их ключей.

В unordered_map ключевое значение обычно используется для уникальной идентификации элемента, в то время как отображаемое значение является объектом, содержащим связанное с этим ключом содержимое. Типы ключа и отображаемого значения могут отличаться.

Внутренне элементы в unordered_map не отсортированы по какому-либо определенному порядку ни по ключу, ни по отображаемым значениям, но они организованы в корзины (buckets) в зависимости от их хэш-значений, что позволяет быстро получать отдельные элементы напрямую по их ключевым значениям (с постоянной средней сложностью по времени).

unordered_map работают быстрее, чем map, при доступе к отдельным элементам по их ключу, хотя они в целом менее эффективны для итерации по подмножеству элементов.

unordered_map реализуют оператор прямого доступа (operator[]), который позволяет прямой доступ к отображаемому значению с использованием его ключевого значения в качестве аргумента.

Итераторы в контейнере являются по крайней мере прямыми итераторами (forward iterators).

### Unordered multimap


Unordered Multimap - это ассоциативный контейнер, который хранит элементы, состоящие из комбинации ключевого значения и отображаемого значения, подобно неупорядоченному отображению (unordered_map), но позволяющий различным элементам иметь эквивалентные ключи.

В unordered_multimap ключевое значение обычно используется для уникальной идентификации элемента, в то время как отображаемое значение является объектом, содержащим связанное с этим ключом содержимое. Типы ключа и отображаемого значения могут отличаться.

Внутренне элементы в unordered_multimap не отсортированы по какому-либо определенному порядку ни по ключу, ни по отображаемым значениям, но они организованы в корзины (buckets) в зависимости от их хэш-значений, что позволяет быстро получать отдельные элементы напрямую по их ключевым значениям (с постоянной средней сложностью по времени).

Элементы с эквивалентными ключами группируются в одну корзину и таким образом, что итератор (см. equal_range) может перебирать их все.

Итераторы в контейнере являются по крайней мере прямыми итераторами (forward iterators).

Обратите внимание, что этот контейнер не определен в своем собственном заголовочном файле, но использует заголовочный файл <unordered_map> вместе с неупорядоченным отображением (unordered_map).

### Битовые контейнеры

Битовые контейнеры нужны для управления последовательностью из N битов.
Cпециальный контейнер для битов в 8 раз эффективнее по памяти.

В std::bitset<N>, который лежит на стеке, количество битов нужно знать "заранее".
Изначально все биты заполняются нулями. 
В контейнере есть несколько разнообразных методов для управления битами (всеми битами или конкретным битом)

Групповые операции, например .count() работают намного быстрее, чем если бы они совершались в обычном цикле for.
Процессоры умеют производить все битовые операции над числом в одну инструкцию.

operator[] (size_t pos) переопределен так, чтобы на его вызов возвращался "легкий" объект
std::bitset::reference, в котором находится указатель на число и "маска" бита.
И в свою очередь у этого объекта переопределен operator=(bool x), который производит запись в нужный бит.

если использовать vector<bool> вместо bitset:
- нельзя использовать укащатели на объект
- отсутствуют элементарные групповые операции над битами

---

## Строки

В STL строки представляются как в формате ASCII, так и Unicode:  
**string** — коллекция однобайтных символов в формате ASCII;  
**wstring** — коллекция двухбайтных символов в формате Unicode;  

## Строковые потоки

strstream — используются для организации STL-строкового сохранения простых типов данных.

Следующий пример берет строку из общего потока ввода и разбивает его на слова (для обработки введенных команд):
```c++
std::getline(std::cin, msg);        // Берем строку из стандартного ввода
std::istringstream iSStream(msg);   // Строкой иницируем поток

std::transform(msg.begin(), msg.end(), msg.begin(),
    [](unsigned char c) { return std::tolower(c); });   // Все символы в нижний регистр

std::string word;
while (iSStream >> word)            // Цикл по словам потока
    commands.push_back(word);       // Сохраняем сллова в вектор команд
```

## Итераторы

Итераторы обеспечивают доступ к элементам контейнера и представляют реализацию распространенного паттерна объектно-ориентированного программирования "Iterator".
С помощью итераторов очень удобно перебирать элементы.
В C++ итераторы реализуют общий интерфейс для различных типов контейнеров, что позволяет использовать единой подход для обращения к элементам разных типов контейнеров.

Стоит отметить, что итераторы имеют только контейнеры, адаптеры контейнеров — типы std::stack, std::queue и std::priority_queue итераторов не имеют.

Существуют три типа итераторов:  
1. (forward) iterator — для обхода коллекции от меньшего индекса к большему;  
2. reverse iterator — для обхода коллекции от большего индекс к меньшему;  
3. random access iterator — для обхода коллекции в любом направлении.  

Важно понимать, что при получении итератора на какой-то элемент коллекции и последующем изменении коллекции итератор может стать непригоден для использования.

## Алгоритмы

Методы перебора всех элементов коллекции и их обработки:  
[count](https://cplusplus.com/reference/algorithm/count/) - Возвращает количество элементов в диапазоне [first,last), которые равны val ;  
[count_if](https://cplusplus.com/reference/algorithm/count_if/)- Возвращает количество элементов в диапазоне, [first,last)для которых значение *pred* истинно.;  
[find](https://cplusplus.com/reference/algorithm/find/) - Возвращает итератор к первому элементу в диапазоне [first,last), который сравнивается с равным *val* . Если такой элемент не найден, функция возвращает *last* .;  
[find_if](https://cplusplus.com/reference/algorithm/find/) - Возвращает итератор к первому элементу в диапазоне, [first,last)для которого *pred* возвращает *true*. Если такой элемент не найден, функция возвращает *last*.;  
adjacent_find;  
for_each;  
mismatch;  
equal;  
search copy;  
copy_backward;  
swap;  
iter_swap;  
swap_ranges;  
fill;  
fill_n;  
generate;  
generate_n;  
replace;  
replace_if;  
transform;  
remove;  
remove_if;  
remove_copy;  
remove_copy_if;  
unique;  
unique_copy;  
reverse;  
reverse_copy;  
rotate;  
rotate_copy;  
random_shuffle;  
partition;  
stable_partition;  

Методы сортировки коллекции:  
[sort](https://cplusplus.com/reference/algorithm/sort/) - Сортирует элементы диапазона [first,last)в порядке возрастания. Элементы сравниваются с использованием operator<для первой версии и комп для второй.;  
stable_sort;  
partial_sort;  
partial_sort_copy;  
nth_element;  
binary_search;  
lower_bound;  
upper_bound;  
equal_range;  
merge;  
inplace_merge;  
includes;  
set_union;  
set_intersection;  
set_difference;  
set_symmetric_difference;  
make_heap;  
push_heap;  
pop_heap;  
sort_heap;  
min;  
max;  
min_element;  
max_element;  
lexographical_compare;  
next_permutation;  
prev_permutation;  

Методы выполнения определенных арифметических операций над членами коллекций:  
[Accumulate](https://cplusplus.com/reference/numeric/accumulate/) - Возвращает результат накопления всех значений в диапазоне [first,last) для *init* .;  
inner_product;  
partial_sum;  
adjacent_difference;  

### Предикаты
Для многих алгоритмов STL можно задать условие, посредством которого алгоритм определит, что ему делать с тем или иным членом коллекции.
Предикат — это функция, которая принимает несколько параметров и возвращает логическое значение (истина/ложь). 
Существует и набор стандартных предикатов.

## Потокобезопасность
Важно понимать, что STL — не потокобезопасная библиотека. Но решить эту проблему очень просто: если два потока используют одну коллекцию, просто реализуйте критическую секцию и Mutex.

---

# Системы сборки

# Пакетные менеджеры

# Контроль версий

# Многопоточность

[Источник](https://radioprog.ru/post/1402)

## Определение

**Многозадачность (multitasking)** – свойство операционной системы или среды выполнения обеспечивать возможность параллельной (или псевдопараллельной) обработки нескольких задач.

**Многопоточность (multithreading)** – свойство платформы (например, операционной системы, виртуальной машины и т. д.) или приложения, состоящее в том, что процесс, порождённый в операционной системе, может состоять из нескольких потоков, выполняющихся «параллельно», то есть без предписанного порядка во времени. При выполнении некоторых задач такое разделение может достичь более эффективного использования ресурсов вычислительной машины.

**Процесс** – экземпляр программы во время выполнения;  
**Потоки** – ветви кода, выполняющиеся «параллельно», то есть без предписанного порядка во времени.

**Процесс** – это абстракция, реализованная на уровне операционной системы. Процесс был придуман для организации всех данных, необходимых для работы программы.  
**Процесс** – это просто контейнер, в котором находятся ресурсы программы:
- адресное пространство;
- потоки;
- открытые файлы;
- дочерние процессы;
- и т.д.;

**Поток** – это абстракция, реализованная на уровне операционной системы. Поток был придуман для контроля выполнения кода программы.

**Поток** – это просто контейнер, в котором находятся:
- счётчик команд;
- регистры;
- стек.

## Проблемы многопоточности


### Race condition

**Состояние гонки** – ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

Суть состояния гонки заключается в том, что итоговое состояние общего ресурса зависит от того, в каком порядке выполняются операции потоками или процессами. 
Если не предусмотрены механизмы синхронизации или взаимного исключения, то возникает конкуренция между потоками за доступ к ресурсу.

Примером состояния гонки может быть следующая ситуация: предположим, что два потока одновременно пытаются увеличить значение одной переменной на 1. 
Оба потока читают текущее значение переменной, увеличивают его и записывают новое значение. 
Однако, если оба потока прочитали старое значение одновременно, то они оба увеличат его на 1 и запишут обновленное значение, игнорируя вклад другого потока. 
В результате значение переменной будет увеличено только на 1, хотя должно было увеличиться на 2.

### Dead lock

**Deadlock** – ситуация, при которой несколько потоков находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать выполнение.

```c++
void fun1() // функция выполняющаяся в одном потоке
{
    mtx1.lock();    // блокировка мьютекса 
    
    mtx2.lock();    // блокировка мьютекса 

}


void fun2() // функция выполняющаяся в другом потоке 
{
    mtx2.lock();    // блокировка мьютекса 
    
    mtx1.lock();    // блокировка мьютекса 

}
```

Пример выше показывает ситуацию с взаимной блокировакой

### Live lock

**Livelock** – очень похож на deadlock, с той лишь разницей, что во время livelock’а потоки во время ожидания выполняют какие-то операции. Однако эти операции не имеют практического смысла, так как потоки несмотря на выполняемые операции и так не могут завершить свои задания. 

### Starvation

## Синтаксис

```c++
#include <thread>       // Подключение либы

this_thread::get_id();  // Индентификатор текущего потока
/*
    this_thread - это пространство имен группирует набор функций, которые обращаются к текущему потоку.
*/

std::thread th(/*указатель на функцию*/);
std::thread th(/*указатель на функцию*/, /*Параметры*/);
std::thread th(/*указатель на функцию*/, std::ref(/*Параметры*/)); // Для передачи параметров по ссылке
std::thread th(/*указатель на класс с перегрженными ()*/, /*Объект*/, /*Параметры*/);
std::thread th(&/*Название класса*/::/*название метода*/, /*Параметры*/);
std::thread th ([](){})

th.join();          // Текущий поток ждет поток th
th.detach();        // Продолжаем выполнение текущего потока не дожидаясь завершения th

std::mutext mtx;
mtx.lock();
/*
    участок кода который выполняется только при разрешении мьютексом
*/
mtx.unlock();

std::lock_guard<mutex> guard(mtx);

std::recursive_mutex rm;    // Рекурсивный мьютекс можно лочить любое количество раз
// но и разблочить его нужно столько же раз

rm.lock();
rm.lock();
rm.lock();

rm.unlock();
rm.unlock();
rm.unlock();

std::unique_lock ul(mtx);
std::unique_lock ul(mtx,std::defer_lock); // не вызывать lock у мьютекса


```

### Lock guard

Своего рода умный указатель для мьютекса. При создании вызывает mutex.lock(), а в деструкторе вызывает mutex.unlock();

### unique_lock 

При выходе из зоны видимости так же освобождает mutex.  
Можно вызвать unlock  вручную

[Цикл видео о этом](https://www.youtube.com/watch?v=NawpxG81RRk&list=PLQOaTSbfxUtAc_RpyDiWCHq0YTzLtVSD0)

# Процессы 

## Межпроцессное взаимодействие

### Shared memmory

### Pipes

### Сериализация

# ОС

# Библиотеки и фреймворки

## Boost

## Qt

## gtest/gmoch

# Практики разработки

# SQL

