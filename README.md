# С++

Этот репозиторий представляет мою позу знаний по С++

В качестве его основы я взял этот [roadmap](https://github.com/salmer/CppDeveloperRoadmap), от которого я отталкивался


# Синтаксис

## Базовые операции 

### Арифметические операции

#### Инкремент и декремент

Префиксный - увеличивает значение до выполенения кода в строке где его вызвали.  
Постфиксный - после выполнения кода в строке в которой его вызвали.
```diff
! Постфиксный немного медленее т.к. возвращает копию переменой которую инкрементировал.
```
[Источник](https://www.cyberforum.ru/cpp-beginners/thread1297462.html)

Операторы могут быть *левоассоциативными* - выполняются слева направо и *правоассоциативными* - выполняются справа налево.  
Большинство операторов левоассоциативны.   
Правоассоциативными операторами являются все унарные операторы, различные операторы присваивания и условный оператор.
  
---

### Логические операции 

---

### Циклы

---

### По битовые операции 

\<< сдвиг влево  
\>> сдвиг вправо  
\~ поразрядная инверсия  
\| поразрядное ИЛИ  
\& поразрядное И  
\^ поразрядное исключающее ИЛИ  

Если нужно записывать определенные биты, не стирая другие:

Чтобы записать единицу в бит n:
```c++
x |= (1 << n);
```

Чтобы записать ноль в бит n:
```c++
x &= ~(1 << n);
```

Если нужно инвертировать состояние бита:
```c++
x ^= (1 << n);
```

Если нужно прочитать отдельный бит:
```c++
unsigned char x = (1 << 2) | (1 << 3) | (1 << 7);  
if (x & (1 << 2)) {  /* во второй бит вписана единица */ }  
if (x & (1 << 3)) {  /* в третий бит вписана единица */ }  
if (x & (1 << 7)) {  /* в седьмой бит вписана единица */ }  
```

Если нужно определить, что в X на N-й позиции:
```c++
bool b = (bool((1 << n)  &  x))
```

Если нужно обнулить один или несколько битов:
```c++
int x = 58;       // 00111010
int y = x & 0x0F; // 00001010

//или

x = x & (~((1<<3)|(1<<5)|(1<<6))); //обнуляем третий, пятый и шестой биты
```

Если нужно установить заданные биты в единицу. Используют оператор |
```c++
int x = 155
x = x | 4;     //устанавливаем в единицу второй бит переменной x
```

Сдвигает число на n разрядов влево
```c++
unsigned char x = 3;  //0b00000011
x = x << 3;           //0b00011000 (24)
```

Сдвиг вправо >>
```c++
unsigned char x = 255;  //0b11111111
x = x >> 3;             //0b00011111 (31)
```

[Источник](https://volstr.ru/?p=36)

---

## Функции

## Типы данных
## Указатели и ссыдки
### Ссылки
### Умные казатели 
### Row указатели (сырые или обычные)
## Организация кодовой базы
## Структуры и классы

Главное различие между классом и структурой в с++, по умолчанию область видимости полей в структуре - public, а у класса - private.

## Библиотеки и взаимодействие с ними
## Обработка ошибок

## Концепции языка

## Шаблоны

## Идиомы

## Стандарты

# ООП

**Инкапсуляция** - механизм позволяющий связывать данные и методы работающие с этими данными в единый объект (использование this для обращения к полям класса)

**Наследование** - концепция согласно которой абстрактный тип данных может наследовать данные и функциональность некоторого существующего типа

**Полиморфизм** - способность функции обрабатывать данные разных типов.  
Перегрузки - вид полиморфизма (*Ad hoc* полиморфизм или специальный полиморфизм)
Инкапсуляция с наследованием нужны для реализации полиморфизмах, сами по себе они бесполезны и даже вредны

**Абстрактный класс** -  базовый класс, который не предполагает создания экземпляров (абстрактный класс объявляется включением хотя бы одной чистой виртуальной функции, типа virtual _сигнатура_функции_ =0;)

**Интерфейс** — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.

#### виртуальный конструктор
Виртуальный **конструктор** невозможен, так как на момент его вызова объекта ещё просто не существует - ещё даже не существует указателя.

Но если бы теоретически "виртуальный конструктор" существовал, то зачем он мог бы быть нужен? Самая простая причина - десериализация. Представим себе функцию/метод, которая на вход получает XML/JSON и каким-то магическим образом догадывается, какой объект был там сериализован, и возвращает объект нужного типа. Более того, в Java это используется... Просто называется по-другому. А называется это Фабричный метод.


#### Dиртуальный деструктор
**Дeструктор** полиморфного базового класса должен объявляться виртуальным. Только так обеспечивается корректное разрушение объекта производного класса через указатель на соответствующий базовый класс.


[Источник](https://www.youtube.com/watch?v=BHNt1fcg8iw)

---

# Патерны

[Источник](https://refactoring.guru/ru/design-patterns/catalo)


## Порождающие

### Адаптер
*Wrapper, Обёртка, AdapterI*

**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.  
Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.

Применение:  
- Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.

---

### Мост
*Bridge*

Пример:  
У вас есть класс геометрических Фигур, который имеет подклассы Круг и Квадрат. Вы хотите расширить иерархию фигур по цвету, то есть иметь Красные и Синие фигуры. Но чтобы всё это объединить, вам придётся создать 4 комбинации подклассов, вроде СиниеКруги и КрасныеКвадраты.  
Паттерн Мост предлагает заменить наследование агрегацией или композицией. Для этого нужно выделить одну из таких «плоскостей» в отдельную иерархию и ссылаться на объект этой иерархии, вместо хранения его состояния и поведения внутри одного класса.

**Мост** — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

---

## Структурные 

## Поведеньческие

---

# Алгоритмы и структуры данных

# STL

## Контейнеры

![алгоритм выбора контейнера](https://github.com/CapSmoIIett/cplusplus/blob/main/images/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B.png)

# Системы сборки

# Пакетные менеджеры

# Контроль версий

# Многопоточность

# ОС

# Библиотеки и фреймворки

## Boost

## Qt

## gtest/gmoch

# Практики разработки

# SQL

